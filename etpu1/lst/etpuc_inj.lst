ETEC Tools V3.00A                  ASH WARE Inc.                  (C) 2015-2020
    /*******************************************************************************
    * This file has been modified by ASH WARE Inc. as allowed per the original 
    * license (see bottom of file), to add features and fix issues.
    *******************************************************************************/
    
    /*******************************************************************************
    *
    *  FREESCALE SEMICONDUCTOR INC. 2012-2014
    *  ALL RIGHTS RESERVED
    *  COPYRIGHT (c)
    *
    ********************************************************************************
    *
    *  FILE NAME:  etpuc_inj.c
    *
    *  DESCRIPTION:
    *    This eTPU function enables to generate complex angle- and time-based output
    *    patterns, primarily dedicated to direct injection timing control.
    *    The INJ channel can control the outputs of up to 3 additional channels, 
    *    called BANK channels (e.g. Boost, Batt, ...).
    *    
    *    An injection sequence consists of injections. Each injection starts at a
    *    defined angle (angle_start) and consists of phases. Each phase is defined
    *    by output states of the INJ and all the BANK channels, a phase duration, 
    *    and options to generate DMA requests at the beginning of the phase.
    *    The number of injections and the number of phases in each injection is 
    *    configurable. More INJ channels (individual injectors) may use separate
    *    injection sequences, or can share the same sequence. 
    *    
    *    There is an INJ parameter tdc_angle, relative to which all angles are 
    *    defined. Positive angles precede the tdc_angle, negative angles come after.
    *    INJ parameter angle_irq defines a tdc_angle-relative angle at which an IRQ
    *    request is generated. The CPU may reconfigure the injection sequence
    *    setting on this interrupt, but not later then the first injection 
    *    angle_start is reached. If the CPU does not reconfigure, the actual 
    *    injection sequence definition is used.
    *    INJ parameter angle_stop defines the latest tdc_angle-relative angle when
    *    the whole injection sequence must be finished. If it is not, all INJ and
    *    BANK outputs are turned to inactive state, whatever injection phase is 
    *    active.
    *       
    *    The CPU can monitor the INJ operation using INJ state variables
    *    injection_counter, phase_counter and error. The reported error flags are:
    *    INJ_ERROR_PREV_INJ_NOT_FINISHED - injection sequence can not start while 
    *      another INJ channel occupies the BANK channels. The injection sequence 
    *      is not generated. The global parameter active_bank_chans keeps
    *      track of which BANK channels are in use.
    *    INJ_ERROR_LATE_START_ANGLE_1ST - the 1st injection start-angle was about
    *      to be scheduled in past, hence the whole injection sequence was skipped. 
    *    INJ_ERROR_LATE_START_ANGLE_NTH - the 2nd or later injection start-angle 
    *      was about to be scheduled in past, hence the rest of the injection 
    *      sequence was skipped.
    *    INJ_ERROR_STOPPED_BY_STOP_ANGLE - the injection sequence was not finished 
    *      before the stop-angle and hence the injection was hard-stopped at the
    *      stop-angle. 
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  Includes
    *******************************************************************************/
    #include <etpu_std.h>
    #include "etpuc_inj.h"
    #include "etpuc_crank.h"
    #include "etpuc_set.h"
    
    /*******************************************************************************
    *  eTPU Function Parameters:
    *
    *  Global
    *  ------
    *  active_bank_chans - individual bits of this parameter determine 
    *    which BANK channels are in use. It is used to prevent from running
    *    2 injections, sharing the same BANK channels, in parallel.
    *  
    *  INJ Channel Parameters (struct INJ_CHAN_PARAMS)
    *  -----------------------------------------------
    *  injection_count - count of injections
    *  injection_counter - counts injections from 1 to num_injection
    *  phase_counter - counts injection phases from 1 to p_injection->phase_count
    *  *p_injection_first - pointer to the first item in the array of injection 
    *                       structures
    *  *p_injection - pointer to the actual item in the array of injection 
    *                 structures
    *  *p_phase - pointer to the actual item in the array of phase structures
    *  error - error flags
    *  bank_chans - up to 3 BANK channel numbers in 3 bytes of uint24_t
    *  bank_chan_count - count of BANK channels; 0 to 3
    *  tdc_angle - TCR2 angle relative to engine-cycle start
    *  tdc_angle_actual - absolute actual TDC TCR2 angle
    *  angle_irq - TDC-relative TCR2 injector IRQ angle
    *  angle_stop - TDC-relative TCR2 injector latest stop angle
    *
    *  Injection Structure Parameters (struct INJ_INJECTION)
    *  -----------------------------------------------------
    *  phase_count - number of injection phases
    *  *p_phase_first - pointer to the first item in the array of phase structures
    *  angle_start - TDC-relative TCR2 injection start angle
    *
    *  Phase Structure Parameters (struct INJ_PHASE)
    *  -----------------------------------------------------
    *  dmas_outputs - DMA requests and output pin states:
    *    Setting of output states during this phase:
    *     bit 0x01 - injector channel output state 
    *     bit 0x02 - bank channel 1 output state (applies only if bank_chan_count > 0) 	    
    *     bit 0x04 - bank channel 2 output state (applies only if bank_chan_count > 1) 	    
    *     bit 0x08 - bank channel 3 output state (applies only if bank_chan_count > 2)
    *    Setting of DMA or DMA&IRQ requests at the beginning of this phase:
    *     bit 0x10 - DMA request from the injector channel  	    
    *     bit 0x20 - DMA&IRQ request from the bank channel 1 (applies only on eTPU2 and if bank_chan_count > 0)	    
    *     bit 0x40 - DMA&IRQ request from the bank channel 2 (applies only on eTPU2 and if bank_chan_count > 1)	    
    *     bit 0x80 - DMA&IRQ request from the bank channel 3 (applies only on eTPU2 and if bank_chan_count > 2)	    
    *  duration - TCR1 time duration of the injection phase
    *  
    ********************************************************************************
    *
    *  Channel Flag usage
    *    Flag0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE (0)  ... Injection sequence is not active
    *    Flag0 = INJ_FLAG0_INJ_SEQ_ACTIVE (1)      ... Injection sequence is active
    *    Flag1 = INJ_FLAG1_IRQ_ANGLE (0)           ... IRQ_ANGLE is scheduled.
    *    Flag1 = INJ_FLAG1_STOP_ANGLE (1)          ... STOP_ANGLE is scheduled.
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  Global Variables
    *******************************************************************************/
    volatile struct INJ_GLOBAL_PARAMS inj_global;
    
    
    /*******************************************************************************
    *  eTPU Class Methods/Fragments
    *******************************************************************************/
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleIRQAngle
    *  DESCRIPTION: Schedule the IRQ_ANGLE, set flag.
    *******************************************************************************/
    void INJ::ScheduleIRQAngle(void)
    {
    	/* Schedule IRQ_ANGLE */
    	ertb = tdc_angle_actual - angle_irq;
1D0C: 0xBFEFFB88   ram   p_23_0 = *((channel int24 *) 0x21);;
1D10: 0xBFE80B85   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x15);;
1D14: 0x1C193FFF   alu    ertB = a-p;;
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    	/* Channel flag */
    	channel.FLAG1 = INJ_FLAG1_IRQ_ANGLE;
    }
1D18: 0xFFFFCEF9   seq  return, no_flush;;
1D1C: 0xFFFACEFB   chan  clear ChannelFlag1, clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleStartAngle1st
    *  DESCRIPTION: Schedule the START_ANGLE_1ST, check if it is not too late.
    *******************************************************************************/
    void INJ::ScheduleStartAngle1st(void)
    {
    	const struct INJ_INJECTION *p_inj;
    
    	/* Channel flag */
    	channel.FLAG0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE;
1D20: 0xCFE8F980   ram   p_31_24 = *((channel int8 *) 0x0);
    :              chan  clear ChannelFlag0;;
    
    	/* If there is at least one injection */
    	if(injection_count > 0)
1D24: 0x0002A019   alu    p_31_24 = p_31_24+0x0, SampleFlags;;
1D28: 0xF0D8EB07   seq  if z==true then goto addr_0x1D60, flush;;
    	{
    		/* Schedule the START_ANGLE_1ST */
    		p_inj = p_injection_first;
1D2C: 0xBFEFFB80   ram   p_23_0 = *((channel int24 *) 0x1);;
    		erta = tdc_angle_actual - p_inj->angle_start;
1D30: 0x00184419   alu    diob = p+0x4;;
1D34: 0x1FEFFBDF   ram   p_23_0 = *((int24 *) diob);;
1D38: 0xBFE80B88   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x21);;
1D3C: 0x1C382FFF   alu    ertA = p-a;;
    		/* check if it is not late */
    		if((int24_t)erta - (int24_t)tcr2 >= 0) 
1D40: 0x000D0419   alu    a = tcr2+0x0;;
1D44: 0x1C3E0EFF   alu    a = ertA-a, SampleFlags;;
1D48: 0xF078EAC7   seq  if n==true then goto addr_0x1D58, no_flush;;
1D4C: 0xCFEFF985   ram   p_31_24 = *((channel int8 *) 0x14);;
    		{
    			channel.OPACA = OPAC_NO_CHANGE; /* all pin states will be set during START_ANGLE_1ST service */
    			channel.TBSA = TBS_M2C1GE;  /* match on angle, capture time */
    			channel.MRLA = MRL_CLEAR;
    			channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    		}
1D50: 0xFFFFCEF9   seq  return, no_flush;;
1D54: 0x48F1FE7F   chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, FutureOutputPin no change on matchA, ActionUnitA: tcr2 >= match, capture tcr1;;
    		else
    		{
    			/* The start-angle is over, skip the rest of injections */
    			/* Set error flag */
    			error |= INJ_ERROR_LATE_START_ANGLE_1ST;
1D58: 0x0C02ABC2   alu    p_31_24 = p_31_24 | 0x2;;
1D5C: 0xCFFFF985   ram   *((channel int8 *) 0x14) = p_31_24;;
    		}
    	}
    }
1D60: 0xFFDFCEF9   seq  return, flush;;
    
    /*******************************************************************************
    *  FUNCTION NAME: StopBankChannels_NoReturn
    *  DESCRIPTION: On all BANK channels:
    *               - disable matches
    *               - turn output pin inactive
    *******************************************************************************/
    _eTPU_fragment INJ::StopBankChannels_NoReturn(void)
    {
    	uint24_t cnt;
    	uint24_t chn;
    	uint24_t out;
    
    	cnt = bank_chan_count;
1D64: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
1D68: 0xBFE21F83   alu    sr = p_31_24+0x0;
    :              ram   diob = *((channel int24 *) 0xD);;
    	chn = bank_chans;
    	out = inactive_polarities;
1D6C: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
1D70: 0x00025411   alu    d = p_31_24+0x0;;
    	while(cnt > 0)
1D74: 0x000AF019   alu    nil = sr+0x0, SampleFlags;;
1D78: 0xF0D8ED27   seq  if z==true then goto addr_0x1DA4, flush;;
    	{
    		chan = (uint8_t)chn;
1D7C: 0x000B4411   alu    chan = diob+0x0;;
    		cnt--;
1D80: 0x7EFA1EBD   alu    sr = sr-0x0-1;
    :              chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, clear MatchEnableLatches;;
    		chn >>= 8;
1D84: 0x1C0B4BD2   alu    diob = diob >> 8;;
    		out >>= 1;
1D88: 0x14045F96   alu    d = (d+0x0) >> 1;;
    		/* Disable match detection */
    		channel.MRLE = MRLE_DISABLE;
    		/* Reset match latches */
    		channel.MRLA = MRL_CLEAR;
    		channel.MRLB = MRL_CLEAR;
    		/* Output pin state */
    		if(out & 0x01)
1D8C: 0x0004A419   alu    p_31_24 = d+0x0;;
1D90: 0xF510ECE7   seq  if p.bit(24)==false then goto addr_0x1D9C, flush;;
    		{
    			channel.PIN = PIN_SET_HIGH;
    		}
1D94: 0xF7F0EBA7   seq  goto addr_0x1D74, no_flush;;
1D98: 0x7FFFFBFE   chan  CurrentOutputPin = high;;
    		else
    		{
    			channel.PIN = PIN_SET_LOW;
    		}
    	}
1D9C: 0xF7F0EBA7   seq  goto addr_0x1D74, no_flush;;
1DA0: 0x7FFFFDFE   chan  CurrentOutputPin = low;;
    }
1DA4: 0x0FFFFFFF   seq   end;;
    
    /*******************************************************************************
    *  FUNCTION NAME: Phase_NoReturn
    *  DESCRIPTION: Processing a single injection phase.
    *******************************************************************************/
    _eTPU_fragment INJ::Phase_NoReturn(void)
    {
    	uint24_t cnt;
    	uint24_t dma;
    	uint24_t out;
    	uint24_t chn;
    	uint24_t end;
    
    	struct INJ_INJECTION *p_inj;
    	struct INJ_PHASE *p_ph;
    
    	p_inj = p_injection;
1DA8: 0xBFEFFB81   ram   p_23_0 = *((channel int24 *) 0x5);;
1DAC: 0xBFA85B82   alu    d = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x9);;
    	p_ph = p_phase;
1DB0: 0x00081419   alu    sr = p+0x0;;
    	end = erta + p_ph->duration; /* this phase end time */
1DB4: 0x000A4419   alu    diob = sr+0x0;;
1DB8: 0x1FEFFBDF   ram   p_23_0 = *((int24 *) diob);;
1DBC: 0x1F1E0FF7   alu    cReg = ertA+p;;
    	dma = p_ph->dmas_outputs; /* this phase DMA requests */
1DC0: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
1DC4: 0x3FF28854   alu    macl = ((s8) p_31_24)+0x0;;
    
    	/* Increment phase counter */
    	phase_counter++;
1DC8: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
1DCC: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
1DD0: 0xCFFFF982   ram   *((channel int8 *) 0x8) = p_31_24;;
    	/* Idle phase? */
    	if(phase_counter > p_inj->phase_count)
1DD4: 0x00044419   alu    diob = d+0x0;;
1DD8: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
1DDC: 0x00020419   alu    a = p_31_24+0x0;;
1DE0: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
1DE4: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
1DE8: 0xF4D8F827   seq  if LowerOrEqual==true then goto addr_0x1F04, flush;;
    	{
    		/* This is the Idle phase */
    
    		/* More injections in the sequence? */
    		if(injection_counter < injection_count)
1DEC: 0xCFEFF981   ram   p_31_24 = *((channel int8 *) 0x4);;
1DF0: 0x00020419   alu    a = p_31_24+0x0;;
1DF4: 0xCFEFF980   ram   p_31_24 = *((channel int8 *) 0x0);;
1DF8: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
1DFC: 0xF4D8F6E7   seq  if LowerOrEqual==true then goto addr_0x1EDC, flush;;
    		{
    			/* There are more injections to do */
    			/* Increment injection counter and p_injection pointer*/
    			injection_counter++;
1E00: 0xCFEFF981   ram   p_31_24 = *((channel int8 *) 0x4);;
1E04: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
1E08: 0xCFFFF981   ram   *((channel int8 *) 0x4) = p_31_24;;
    			p_inj++;
1E0C: 0x00245411   alu    d = d+0x8;;
    			p_injection = p_inj;
1E10: 0xBFF47B81   alu    p = d+0x0;
    :              ram   *((channel int24 *) 0x5) = p_23_0;;
    			/* Reset phase counters and initialize p_phase pointer */
    			phase_counter = 0;
1E14: 0xCFFFF902   ram   *((channel int8 *) 0x8) =  0;;
    			p_phase = p_inj->p_phase_first;
1E18: 0x00044419   alu    diob = d+0x0;;
1E1C: 0x1FEFFB9F   ram   p_23_0 = *((int24 *) diob++);;
1E20: 0xBFFFFB82   ram   *((channel int24 *) 0x9) = p_23_0;;
    
    			/* Schedule the next injection start-angle PHASE */
    			erta = tdc_angle_actual - p_inj->angle_start;
1E24: 0x1FEFFBDF   ram   p_23_0 = *((int24 *) diob);;
1E28: 0xBFE80B88   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x21);;
1E2C: 0x1C382FFF   alu    ertA = p-a;;
    			/* check if it is not late */
    			if((int24_t)erta - (int24_t)tcr2 >= 0)
1E30: 0x000D0419   alu    a = tcr2+0x0;;
1E34: 0x1C3E0EFF   alu    a = ertA-a, SampleFlags;;
1E38: 0xF058F567   seq  if n==true then goto addr_0x1EAC, flush;;
    			{
    				/* Schedule next phase output on INJ channel */
    				out = p_phase->dmas_outputs;
1E3C: 0xBFEFFF82   ram   diob = *((channel int24 *) 0x9);;
1E40: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
1E44: 0x3FF21874   alu    sr = ((s8) p_31_24)+0x0;;
    				if(out & 0x01)
1E48: 0x000AA419   alu    p_31_24 = sr+0x0;;
1E4C: 0xF510F2C7   seq  if p.bit(24)==false then goto addr_0x1E58, flush;;
    				{
    					channel.OPACA = OPAC_MATCH_HIGH;
    				}
1E50: 0xF7F0F2E7   seq  goto addr_0x1E5C, no_flush;;
1E54: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    				else
    				{
    					channel.OPACA = OPAC_MATCH_LOW;
1E58: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    				}
    				channel.MRLA = MRL_CLEAR;
1E5C: 0x4FF1FE7F   chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, ActionUnitA: tcr2 >= match, capture tcr1;;
    				channel.TBSA = TBS_M2C1GE;  /* match on angle, capture time */
    				channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    				/* Schedule next phase outputs on BANK channels */
    				end = erta;
1E60: 0xBFAE0B83   alu    cReg = ertA+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0xD);;
    				cnt = bank_chan_count;
1E64: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
1E68: 0x00025411   alu    d = p_31_24+0x0;;
    				chn = bank_chans;
1E6C: 0x00088411   alu    macl = p+0x0;;
    				while(cnt > 0)
1E70: 0x0004F019   alu    nil = d+0x0, SampleFlags;;
1E74: 0xF0D8FD47   seq  if z==true then goto addr_0x1FA8, flush;;
    				{
    					cnt--;
1E78: 0x1EF45FF7   alu    d = d-0x0-1;;
    					chan = (uint8_t)chn;
1E7C: 0x00084401   alu    chan = macl+0x0;;
    					chn = chn >> 8;
1E80: 0x00000440   alu    p = ((u24) 0)+0x2;;
1E84: 0x3F188F9A   alu    macl = macl >> (2^^(p+1));;
    					erta = end;
1E88: 0x00012409   alu    ertA = cReg+0x0;;
    					out >>= 1;
1E8C: 0x1C0A1792   alu    sr = (sr+0x0) >> 1;;
    					if(out & 0x01)
1E90: 0x000AA419   alu    p_31_24 = sr+0x0;;
1E94: 0xF510F507   seq  if p.bit(24)==false then goto addr_0x1EA0, flush;;
    					{
    						channel.OPACA = OPAC_MATCH_HIGH;
    					}
1E98: 0xF7F0F527   seq  goto addr_0x1EA4, no_flush;;
1E9C: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    					else
    					{
    						channel.OPACA = OPAC_MATCH_LOW;
1EA0: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    					}
    					channel.MRLA = MRL_CLEAR;
    					channel.TBSA = TBS_M2C1GE;  /* match on angle, capture time */
    					channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    				}
1EA4: 0xF7F0F387   seq  goto addr_0x1E70, no_flush;;
1EA8: 0x4FF1FE7F   chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, ActionUnitA: tcr2 >= match, capture tcr1;;
    			}
    			else
    			{
    				/* The start-angle is over, skip the rest of injections */
    				/* Set error flag */
    				error |= INJ_ERROR_LATE_START_ANGLE_NTH;
1EAC: 0xDFE87985   ram   p_31_24 = *((channel int8 *) 0x14);
    :              chan  clear ChannelFlag0, clear MatchRecognitionLatchA;;
1EB0: 0x0C12AB82   alu    p_31_24 = p_31_24 | 0x4;;
1EB4: 0xCFFFF985   ram   *((channel int8 *) 0x14) = p_31_24;;
    				/* Free BANK channels for other injectors */
    				inj_global.active_bank_chans.parts.bits31_24 &= ~bank_chans_mask.parts.bits31_24;
1EB8: 0xCFEFF884   ram   p_31_0 = *((channel int32 *) 0x10);;
1EBC: 0x00020419   alu    a = p_31_24+0x0;;
1EC0: 0x1E3F0FFF   alu    a = ((u24) 0)-a-1;;
1EC4: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
1EC8: 0x3F32AFF2   alu    p_31_24 = p_31_24 & a;;
1ECC: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    				inj_global.active_bank_chans.parts.bits23_0  &= ~bank_chans_mask.parts.bits23_0;
1ED0: 0x9E0F0B04   alu    a = ((u24) 0)-p-1;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
1ED4: 0x2F387FF2   alu    p = p & a;;
1ED8: 0x8FFFFB04   ram   *((global int24 *) 0x11) = p_23_0;
    :              seq   end;;
    				/* Channel flag */
    				channel.FLAG0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE;
    				channel.MRLA = MRL_CLEAR;
    			}
    		}
    		else
    		{
    			/* This is the last injection */
    			/* Free BANK channels for other injectors */
    			inj_global.active_bank_chans.parts.bits31_24 &= ~bank_chans_mask.parts.bits31_24;
1EDC: 0xDFE87884   ram   p_31_0 = *((channel int32 *) 0x10);
    :              chan  clear ChannelFlag0, clear MatchRecognitionLatchA;;
1EE0: 0x00020419   alu    a = p_31_24+0x0;;
1EE4: 0x1E3F0FFF   alu    a = ((u24) 0)-a-1;;
1EE8: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
1EEC: 0x3F32AFF2   alu    p_31_24 = p_31_24 & a;;
1EF0: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    			inj_global.active_bank_chans.parts.bits23_0  &= ~bank_chans_mask.parts.bits23_0;
1EF4: 0x9E0F0B04   alu    a = ((u24) 0)-p-1;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
1EF8: 0x2F387FF2   alu    p = p & a;;
1EFC: 0x9FFFFB04   ram   *((global int24 *) 0x11) = p_23_0;;
    			/* Channel flag */
    			channel.FLAG0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE;
    			channel.MRLA = MRL_CLEAR;
    			/* Reset injection counter */
    			injection_counter = 0;
1F00: 0xC7FFF901   ram   *((channel int8 *) 0x4) =  0;
    :              seq   end;;
    		}
    	}
    	else
    	{
    		/* Last injection phase? */
    		if(phase_counter < p_inj->phase_count)
1F04: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
1F08: 0x00020419   alu    a = p_31_24+0x0;;
1F0C: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
1F10: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
1F14: 0xF090F987   seq  if cFlag==false then goto addr_0x1F30, flush;;
    		{
    			/* This is not the last phase */
    			p_ph++;
1F18: 0x001A1419   alu    sr = sr+0x4;;
    			p_phase = p_ph; /* store pointer to the next phase */
1F1C: 0xBFFA7B82   alu    p = sr+0x0;
    :              ram   *((channel int24 *) 0x9) = p_23_0;;
    			out = p_ph->dmas_outputs; /* next phase outputs */
1F20: 0x000A4419   alu    diob = sr+0x0;;
1F24: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
    		}
1F28: 0xF7F0F9C7   seq  goto addr_0x1F38, no_flush;;
1F2C: 0x3FF21874   alu    sr = ((s8) p_31_24)+0x0;;
    		else /* phase_counter == p_inj->phase_count */
    		{
    			/* This is the last phase */
    			out = inactive_polarities;
1F30: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
1F34: 0x00021419   alu    sr = p_31_24+0x0;;
    		}
    	
    		/* Schedule next phase output on INJ channel */
    		erta = end;
1F38: 0x00012409   alu    ertA = cReg+0x0;;
    		if(out & 0x01)
1F3C: 0x000AA419   alu    p_31_24 = sr+0x0;;
1F40: 0xF510FA67   seq  if p.bit(24)==false then goto addr_0x1F4C, flush;;
    		{
    			channel.OPACA = OPAC_MATCH_HIGH;
    		}
1F44: 0xF7F0FA87   seq  goto addr_0x1F50, no_flush;;
1F48: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    		else
    		{
    			channel.OPACA = OPAC_MATCH_LOW;
1F4C: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    		}
    		channel.MRLA = MRL_CLEAR;
1F50: 0x4FF0FE7F   chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, ActionUnitA: tcr1 >= match, capture tcr1;;
    		channel.TBSA = TBS_M1C1GE;  /* match on time, capture time */
    		channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    		/* Generate DMA on INJ channel */
    		if(dma & 0x10)
1F54: 0x0008A409   alu    p_31_24 = macl+0x0;;
1F58: 0xF610FB07   seq  if p.bit(28)==false then goto addr_0x1F60, flush;;
    		{
    			channel.CIRC = CIRC_DATA_FROM_SERVICED;
1F5C: 0xFFFF7EF9   chan  set SvcdChan DataTransferIntr;;
    		}
    		/* Schedule next phase outputs on BANK channels */
    		cnt = bank_chan_count;
1F60: 0xCFEFF883   ram   p_31_0 = *((channel int32 *) 0xC);;
1F64: 0x00025411   alu    d = p_31_24+0x0;;
    		chn = bank_chans;
1F68: 0x00088411   alu    macl = p+0x0;;
    		while(cnt > 0)
1F6C: 0x0004F019   alu    nil = d+0x0, SampleFlags;;
1F70: 0xF0D8FD47   seq  if z==true then goto addr_0x1FA8, flush;;
    		{
    			cnt--;
1F74: 0x1EF45FF7   alu    d = d-0x0-1;;
    			chan = (uint8_t)chn;
1F78: 0x00084401   alu    chan = macl+0x0;;
    			chn = chn >> 8;
1F7C: 0x00000440   alu    p = ((u24) 0)+0x2;;
1F80: 0x3F188F9A   alu    macl = macl >> (2^^(p+1));;
    			erta = end;
1F84: 0x00012409   alu    ertA = cReg+0x0;;
    			out >>= 1;
1F88: 0x1C0A1792   alu    sr = (sr+0x0) >> 1;;
    			if(out & 0x01)
1F8C: 0x000AA419   alu    p_31_24 = sr+0x0;;
1F90: 0xF510FCE7   seq  if p.bit(24)==false then goto addr_0x1F9C, flush;;
    			{
    				channel.OPACA = OPAC_MATCH_HIGH;
    			}
1F94: 0xF7F0FD07   seq  goto addr_0x1FA0, no_flush;;
1F98: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    			else
    			{
    				channel.OPACA = OPAC_MATCH_LOW;
1F9C: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    			}
    			channel.MRLA = MRL_CLEAR;
    			channel.TBSA = TBS_M1C1GE;  /* match on time, capture time */
    			channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    			/* Generate DMA&IRQ on BANK channels */
    #if defined(__TARGET_ETPU2__)
    			dma >>= 1;
    			if(dma & 0x10)
    			{
    				channel.CIRC = CIRC_BOTH_FROM_SELECTED;
    			}
    #endif
    		}
1FA0: 0xF7F0FB67   seq  goto addr_0x1F6C, no_flush;;
1FA4: 0x4FF0FE7F   chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, ActionUnitA: tcr1 >= match, capture tcr1;;
    	}
    }
1FA8: 0x0FFFFFFF   seq   end;;
    
    /*******************************************************************************
    *  FUNCTION NAME: Init_NoReturn
    *  DESCRIPTION: Initialize the channel to run the INJ function.
    *******************************************************************************/
    _eTPU_fragment INJ::Init_NoReturn(void)
    {
    	/* Stop the channel */
    	/* Disable event handling */
    	channel.MTD = MTD_DISABLE;
1FAC: 0xFB77FEFB   chan  clear TransitionDetectionLatches, clear MatchEnableLatches, DisableMatchTransitionServicing;;
    	/* Disable match detection */
    	channel.MRLE = MRLE_DISABLE;
    	/* Reset all latches */
    	channel.TDL = TDL_CLEAR;
    	channel.LSR = LSR_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    
    	/* Initialize the channel */
    	/* Set channel mode: either match non-blocking single transition */
    	channel.PDCM = PDCM_EM_NB_ST;
    	/* Time base selection */
    	channel.TBSA = TBS_M1C1GE;
    	channel.TBSB = TBS_M2C2GE;
    	/* Input pin action control */
    	channel.IPACA = IPAC_NO_DETECT;
    	channel.IPACB = IPAC_NO_DETECT;
    	/* Output pin state and Output pin action control */
    	if(channel.FM0 == INJ_FM0_ACTIVE_HIGH)
1FB0: 0xF3F8FE07   seq  if FunctionMode0==true then goto addr_0x1FC0, no_flush;;
1FB4: 0x581036A5   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr2 >= match, capture tcr2,
    :                    clear LinkServiceRequest, mode = either match non blocking single transition, detectA = off, detectB = off;;
    	{
    		channel.PIN = PIN_SET_LOW;
    		channel.OPACA = OPAC_MATCH_LOW;
    		channel.OPACB = OPAC_NO_CHANGE;
    	}
1FB8: 0xF7F0FE27   seq  goto addr_0x1FC4, no_flush;;
1FBC: 0x4A1FFDFE   chan  CurrentOutputPin = low, FutureOutputPin low on matchA, FutureOutputPin no change on matchB;;
    	else
    	{
    		channel.PIN = PIN_SET_HIGH;
1FC0: 0x491FFBFE   chan  CurrentOutputPin = high, FutureOutputPin high on matchA, FutureOutputPin no change on matchB;;
    		channel.OPACA = OPAC_MATCH_HIGH;
    		channel.OPACB = OPAC_NO_CHANGE;
    	}
    	/* Enable output pin buffer */
    	channel.TBSA = TBSA_SET_OBE;
1FC4: 0x4FF8FFFF   chan  enable output buffer;;
    	
    	/* Free BANK channels */
    	inj_global.active_bank_chans.parts.bits31_24 &= ~bank_chans_mask.parts.bits31_24;
1FC8: 0xCFEFF884   ram   p_31_0 = *((channel int32 *) 0x10);;
1FCC: 0x00020419   alu    a = p_31_24+0x0;;
1FD0: 0x1E3F0FFF   alu    a = ((u24) 0)-a-1;;
1FD4: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
1FD8: 0x2F32AFF2   alu    p_31_24 = p_31_24 & a;;
1FDC: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    	inj_global.active_bank_chans.parts.bits23_0  &= ~bank_chans_mask.parts.bits23_0;
1FE0: 0x9E0F0B04   alu    a = ((u24) 0)-p-1;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
1FE4: 0x2F387FF2   alu    p = p & a;;
    
    	/* On INJ channel schedule the first IRQ_ANGLE and START_ANGLE_1ST */
    	if(channel.FM1 == INJ_FM1_CHANNEL_INJ)
1FE8: 0xF3B90087   seq  if FunctionMode1==true then goto addr_0x2010, no_flush;;
1FEC: 0x9FFFFB04   ram   *((global int24 *) 0x11) = p_23_0;;
    	{
    		/* Enable event handling */
    		channel.MTD = MTD_ENABLE;
1FF0: 0xDF2FFA87   ram   p_23_0 = *((channel int24 *) 0x1D);
    :              chan  EnableMatchTransitionServicing;;
    		
    		/* Initialize actual TDC angle */
    		tdc_angle_actual = eng_cycle_tcr2_start + tdc_angle;
1FF4: 0x9FE80B01   alu    a = p+0x0;
    :              ram   p_23_0 = *((global int24 *) 0x5);;
1FF8: 0xBF384F88   alu    diob = p+a;
    :              ram   *((channel int24 *) 0x21) = diob;;
    
            if (eng_pos_state != ENG_POS_FULL_SYNC)
1FFC: 0xCFEFF100   ram   p_31_24 = *((global int8 *) 0x0);;
2000: 0x0802FBEA   alu    nil = p_31_24 ^ 0x3, SampleFlags;;
2004: 0xF0D10087   seq  if z==false then goto addr_0x2010, flush;;
            {
                /* only fully start the injection processing once sync is achieved */
                return;
            }
    
    		/* Schedule IRQ_ANGLE */
    		ScheduleIRQAngle();
2008: 0xFFD0E867   seq  call addr_0x1D0C, flush;;
    		
    		/* Schedule START_ANGLE_1ST */
    		ScheduleStartAngle1st();
200C: 0xFFD0E907   seq  call addr_0x1D20, flush;;
    	}
    }
2010: 0x0FFFFFFF   seq   end;;
    
    
    /*******************************************************************************
    *  eTPU Function
    *******************************************************************************/
    
    /**************************************************************************
    * THREAD NAME: INIT
    * DESCRIPTION: Initialize the channel to run the INJ function.
    *              This HSR thread must be executed on all INJ and all BANK 
    *              channels. 
    **************************************************************************/
    _eTPU_thread INJ::INIT(_eTPU_matches_disabled)
    {
    	Init_NoReturn();
    }
    
    /**************************************************************************
    * THREAD NAME: STOP
    * DESCRIPTION: Stop the running injection sequence.
    *              The next injection sequence will start normally. 
    **************************************************************************/
    _eTPU_thread INJ::STOP(_eTPU_matches_disabled)
    {
    	/* Stop the INJ channel - schedule an immediate match A to set pin inactive
    	   and rewrite any match already scheduled */
    	/* Output pin action control */
    	if(channel.FM0 == INJ_FM0_ACTIVE_HIGH)
2014: 0xF3D90107   seq  if FunctionMode0==true then goto addr_0x2020, flush;;
    	{
    		channel.OPACA = OPAC_MATCH_LOW;
    	}
2018: 0xF7F10127   seq  goto addr_0x2024, no_flush;;
201C: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    	else
    	{
    		channel.OPACA = OPAC_MATCH_HIGH;
2020: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    	}
    	/* Time base selection */
    	channel.TBSA = TBS_M1C1GE;
2024: 0x4FF0FFFF   chan  ActionUnitA: tcr1 >= match, capture tcr1;;
    	/* Schedule match now */
    	erta = tcr1;
2028: 0xBFEC2B84   alu    ertA = tcr1+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x11);;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
202C: 0xDFE83984   ram   p_31_24 = *((channel int8 *) 0x10);
    :              chan  clear ChannelFlag0, clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA;;
    	/* Channel flag */
    	channel.FLAG0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE;
    
    	/* Free BANK channels for other injectors */
    	inj_global.active_bank_chans.parts.bits31_24 &= ~bank_chans_mask.parts.bits31_24;
2030: 0x00020419   alu    a = p_31_24+0x0;;
2034: 0x1E3F0FFF   alu    a = ((u24) 0)-a-1;;
2038: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
203C: 0x2F32AFF2   alu    p_31_24 = p_31_24 & a;;
2040: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    	inj_global.active_bank_chans.parts.bits23_0  &= ~bank_chans_mask.parts.bits23_0;
2044: 0x9E0F0B04   alu    a = ((u24) 0)-p-1;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
2048: 0x2F387FF2   alu    p = p & a;;
    
    	/* Clear the immediate match */
    	channel.MRLA = MRL_CLEAR;
    	
    	/* Stop the BANK channels */
    	StopBankChannels_NoReturn();
204C: 0xF7F0EB27   seq  goto addr_0x1D64, no_flush;;
2050: 0x9FFFFB04   ram   *((global int24 *) 0x11) = p_23_0;;
    }
    
    /**************************************************************************
    * THREAD NAME: UPDATE
    * DESCRIPTION: The injection sequence parameters are updated. 
    *              Check if it is not too late and reschedule START_ANGLE_1ST. 
    **************************************************************************/
    _eTPU_thread INJ::UPDATE(_eTPU_matches_disabled)
    {
    	ScheduleStartAngle1st();
2054: 0xFFD0E907   seq  call addr_0x1D20, flush;;
    }
2058: 0x0FFFFFFF   seq   end;;
    
    /**************************************************************************
    * THREAD NAME: START_ANGLE_1ST
    * DESCRIPTION: The first injection first PHASE. Check if the previous 
    *              injection sequence (driven by another INJ channel, but 
    *              sharing the same BANK channels) is already finished.
    **************************************************************************/
    _eTPU_thread INJ::START_ANGLE_1ST(_eTPU_matches_disabled)
    {
    	uint24_t out;
    	uint24_t cnt;
    	uint24_t chn;
    	uint8_t  inj_chan;
    	
    	/* prioritize Link service over Match service */
    	if(channel.LSR == 1) 
205C: 0xF318FD67   seq  if SampledLinkServiceRequest==true then goto addr_0x1FAC, flush;;
    	{
    		Init_NoReturn();
    	}
        else
        {
    		/* Check if previous injection sequence is finished */
    		if (((inj_global.active_bank_chans.parts.bits23_0 & bank_chans_mask.parts.bits23_0) == 0) &&
    		    ((inj_global.active_bank_chans.parts.bits31_24 & bank_chans_mask.parts.bits31_24) == 0))
2060: 0x9FEFFB04   ram   p_23_0 = *((global int24 *) 0x11);;
2064: 0xBFE80B84   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x11);;
2068: 0x2B190FF2   alu    a = a & p, SampleFlags;;
206C: 0xF0D10947   seq  if z==false then goto addr_0x2128, flush;;
2070: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
2074: 0x00020419   alu    a = p_31_24+0x0;;
2078: 0xCFEFF984   ram   p_31_24 = *((channel int8 *) 0x10);;
207C: 0x3B32AFF2   alu    p_31_24 = p_31_24 & a, SampleFlags;;
2080: 0xF0D10947   seq  if z==false then goto addr_0x2128, flush;;
    		{
    			/* Occupy BANK channels */
    			inj_global.active_bank_chans.parts.bits31_24 |= bank_chans_mask.parts.bits31_24;
2084: 0xCFE9F984   ram   p_31_24 = *((channel int8 *) 0x10);
    :              chan  set ChannelFlag0;;
2088: 0x00020419   alu    a = p_31_24+0x0;;
208C: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
2090: 0x3F32AFF0   alu    p_31_24 = p_31_24 | a;;
2094: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    			inj_global.active_bank_chans.parts.bits23_0  |= bank_chans_mask.parts.bits23_0;
2098: 0x9FE80B04   alu    a = p+0x0;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
209C: 0x2F387FF0   alu    p = p | a;;
20A0: 0x9DFFAB04   alu    p_31_24 = ((u24) 0)+0x1;
    :              ram   *((global int24 *) 0x11) = p_23_0;;
    			/* Channel flag */
    			channel.FLAG0 = INJ_FLAG0_INJ_SEQ_ACTIVE;
    			/* Init injection and phase counters */
    			injection_counter = 1;
20A4: 0xCFFFF981   ram   *((channel int8 *) 0x4) = p_31_24;;
    			phase_counter = 0;
20A8: 0xCFFFF902   ram   *((channel int8 *) 0x8) =  0;;
    			/* Initialize p_injection and p_phase pointers */
    			p_injection = p_injection_first;
20AC: 0xBFEFFB80   ram   p_23_0 = *((channel int24 *) 0x1);;
20B0: 0xBFF84B81   alu    diob = p+0x0;
    :              ram   *((channel int24 *) 0x5) = p_23_0;;
    			p_phase = p_injection_first->p_phase_first;
20B4: 0x1FEFFBDF   ram   p_23_0 = *((int24 *) diob);;
20B8: 0xBFF84B82   alu    diob = p+0x0;
    :              ram   *((channel int24 *) 0x9) = p_23_0;;
    
    			/* Set pin states */
    			out = p_phase->dmas_outputs;
20BC: 0xFFEFF9D9   ram   p_31_24 = *((int8 *) diob);;
20C0: 0x3FF21874   alu    sr = ((s8) p_31_24)+0x0;;
    			cnt = bank_chan_count;
20C4: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
20C8: 0xBFA25F83   alu    d = p_31_24+0x0;
    :              ram   diob = *((channel int24 *) 0xD);;
    			chn = bank_chans;
20CC: 0x000B7411   alu    mach = diob+0x0;;
    			/* on INJ channel */
    			if(out & 0x01)
20D0: 0x000AA419   alu    p_31_24 = sr+0x0;;
20D4: 0xF5110707   seq  if p.bit(24)==false then goto addr_0x20E0, flush;;
    			{
    				channel.PIN = PIN_SET_HIGH;
    			}
20D8: 0xF7F10727   seq  goto addr_0x20E4, no_flush;;
20DC: 0x7FFFFBFE   chan  CurrentOutputPin = high;;
    			else
    			{
    				channel.PIN = PIN_SET_LOW;
20E0: 0x7FFFFDFE   chan  CurrentOutputPin = low;;
    			}
    			/* on BANK channels */
    			inj_chan = chan;
20E4: 0x00090401   alu    cReg = chan+0x0;;
    			while(cnt > 0)
20E8: 0x0004F019   alu    nil = d+0x0, SampleFlags;;
20EC: 0xF0D908E7   seq  if z==true then goto addr_0x211C, flush;;
    			{
    				cnt--;
20F0: 0x1EF45FF7   alu    d = d-0x0-1;;
    				chan = (uint8_t)chn;
20F4: 0x00074401   alu    chan = mach+0x0;;
    				chn = chn >> 8;
20F8: 0x00000440   alu    p = ((u24) 0)+0x2;;
20FC: 0x3F177F9A   alu    mach = mach >> (2^^(p+1));;
    				out >>= 1;
2100: 0x1C0A1792   alu    sr = (sr+0x0) >> 1;;
    				if(out & 0x01)
2104: 0x000AA419   alu    p_31_24 = sr+0x0;;
2108: 0xF51108A7   seq  if p.bit(24)==false then goto addr_0x2114, flush;;
    				{
    					channel.PIN = PIN_SET_HIGH;
    				}
210C: 0xF7F10747   seq  goto addr_0x20E8, no_flush;;
2110: 0x7FFFFBFE   chan  CurrentOutputPin = high;;
    				else
    				{
    					channel.PIN = PIN_SET_LOW;
    				}
    			}
2114: 0xF7F10747   seq  goto addr_0x20E8, no_flush;;
2118: 0x7FFFFDFE   chan  CurrentOutputPin = low;;
    			chan = inj_chan;
211C: 0x00014401   alu    chan = cReg+0x0;;
    			erta = tcr1;
    
    			/* Process as a normal PHASE */
    			Phase_NoReturn();
2120: 0xF7F0ED47   seq  goto addr_0x1DA8, no_flush;;
2124: 0x000C2419   alu    ertA = tcr1+0x0;;
    		}
    		else
    		{
    			/* Set error flag */
    			error |= INJ_ERROR_PREV_INJ_NOT_FINISHED;
2128: 0xCFEFF985   ram   p_31_24 = *((channel int8 *) 0x14);;
212C: 0x0C02ABA2   alu    p_31_24 = p_31_24 | 0x1;;
2130: 0xC7FFF985   ram   *((channel int8 *) 0x14) = p_31_24;
    :              seq   end;;
    		}
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: PHASE
    * DESCRIPTION: A single injection phase.
    **************************************************************************/
    _eTPU_thread INJ::PHASE(_eTPU_matches_disabled)
    {
    	/* prioritize Link service over Match service */
    	if(channel.LSR == 1) 
2134: 0xF310ED47   seq  if SampledLinkServiceRequest==false then goto addr_0x1DA8, flush;;
    	{
    		Init_NoReturn();
2138: 0xF7D0FD67   seq  goto addr_0x1FAC, flush;;
    	}
        else
        {
            Phase_NoReturn();
        }
    }
    
    /**************************************************************************
    * THREAD NAME: STOP_ANGLE_WHILE_ACTIVE
    * DESCRIPTION: Stop the active sequence of injections.
    *              Update TDC for next engine cycle.
    *              Schedule IRQ_ANGLE.
    *              Schedule START_ANGLE_1ST.
    **************************************************************************/
    _eTPU_thread INJ::STOP_ANGLE_WHILE_ACTIVE(_eTPU_matches_disabled)
    {
    	/* prioritize Link service over Match service */
    	if(channel.LSR == 1) 
213C: 0xF318FD67   seq  if SampledLinkServiceRequest==true then goto addr_0x1FAC, flush;;
    	{
    		Init_NoReturn();
    	}
    	else
    	{
    		/* Set error flag */
    		error |= INJ_ERROR_STOPPED_BY_STOP_ANGLE;
2140: 0xDBEF7985   ram   p_31_24 = *((channel int8 *) 0x14);
    :              chan  clear MatchRecognitionLatchA, clear MatchEnableLatches;;
2144: 0x0C22AB82   alu    p_31_24 = p_31_24 | 0x8;;
    
    		/* INJ channel */
    		/* Disable match detection */
    		channel.MRLE = MRLE_DISABLE;
    		/* Reset match A latch */
    		channel.MRLA = MRL_CLEAR;
    		/* Output pin state */
    		if(channel.FM0 == INJ_FM0_ACTIVE_HIGH)
2148: 0xF3F90AC7   seq  if FunctionMode0==true then goto addr_0x2158, no_flush;;
214C: 0xCFFFF985   ram   *((channel int8 *) 0x14) = p_31_24;;
    		{
    			channel.PIN = PIN_SET_LOW;
    		}
2150: 0xF7F10AE7   seq  goto addr_0x215C, no_flush;;
2154: 0x7FFFFDFE   chan  CurrentOutputPin = low;;
    		else
    		{
    			channel.PIN = PIN_SET_HIGH;
2158: 0x7FFFFBFE   chan  CurrentOutputPin = high;;
    		}
    		/* Channel flag */
    		channel.FLAG0 = INJ_FLAG0_INJ_SEQ_NOT_ACTIVE;
215C: 0xCFE8F884   ram   p_31_0 = *((channel int32 *) 0x10);
    :              chan  clear ChannelFlag0;;
    		
    		/* Free BANK channels for other injectors */
    		inj_global.active_bank_chans.parts.bits31_24 &= ~bank_chans_mask.parts.bits31_24;
2160: 0x00020419   alu    a = p_31_24+0x0;;
2164: 0x1E3F0FFF   alu    a = ((u24) 0)-a-1;;
2168: 0xCFEFF104   ram   p_31_24 = *((global int8 *) 0x10);;
216C: 0x2F32AFF2   alu    p_31_24 = p_31_24 & a;;
2170: 0xCFFFF104   ram   *((global int8 *) 0x10) = p_31_24;;
    		inj_global.active_bank_chans.parts.bits23_0  &= ~bank_chans_mask.parts.bits23_0;
2174: 0x9E0F0B04   alu    a = ((u24) 0)-p-1;
    :              ram   p_23_0 = *((global int24 *) 0x11);;
2178: 0x2F387FF2   alu    p = p & a;;
217C: 0x9FFFFB04   ram   *((global int24 *) 0x11) = p_23_0;;
    		
    		/* Update actual TDC angle for this cycle */
    		tdc_angle_actual += eng_cycle_tcr2_ticks;
2180: 0x9FEFFB00   ram   p_23_0 = *((global int24 *) 0x1);;
2184: 0xBFE80B88   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x21);;
    
    		/* Schedule IRQ_ANGLE */
    		ScheduleIRQAngle();
2188: 0xFFF0E867   seq  call addr_0x1D0C, no_flush;;
218C: 0xBF387B88   alu    p = p+a;
    :              ram   *((channel int24 *) 0x21) = p_23_0;;
    
    		/* Schedule START_ANGLE_1ST */
    		ScheduleStartAngle1st();
2190: 0xFFD0E907   seq  call addr_0x1D20, flush;;
    		
    		/* BANK channels */
    		StopBankChannels_NoReturn();
2194: 0xF7D0EB27   seq  goto addr_0x1D64, flush;;
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: STOP_ANGLE_POST_ACTIVE
    * DESCRIPTION: The injection sequence is already finished, no need to stop
    *              it.
    *              Update TDC for next engine cycle.
    *              Schedule IRQ_ANGLE.
    *              Schedule START_ANGLE_1ST.
    **************************************************************************/
    _eTPU_thread INJ::STOP_ANGLE_POST_ACTIVE(_eTPU_matches_disabled)
    {
    	/* prioritize Link service over Match service */
    	if(channel.LSR == 1) 
2198: 0xF318FD67   seq  if SampledLinkServiceRequest==true then goto addr_0x1FAC, flush;;
    	{
    		Init_NoReturn();
    	}
        else
        {
    		/* Update actual TDC angle for this cycle */
    		tdc_angle_actual += eng_cycle_tcr2_ticks;
219C: 0x9FEFFB00   ram   p_23_0 = *((global int24 *) 0x1);;
21A0: 0xBFE80B88   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x21);;
    
    		/* Schedule IRQ_ANGLE */
    		ScheduleIRQAngle();
21A4: 0xFFF0E867   seq  call addr_0x1D0C, no_flush;;
21A8: 0xBF387B88   alu    p = p+a;
    :              ram   *((channel int24 *) 0x21) = p_23_0;;
    
    		/* Schedule START_ANGLE_1ST */
    		ScheduleStartAngle1st();
21AC: 0xFFD0E907   seq  call addr_0x1D20, flush;;
    	}
    }
21B0: 0x0FFFFFFF   seq   end;;
    
    /**************************************************************************
    * THREAD NAME: IRQ_ANGLE
    * DESCRIPTION: Generate channel interrupt.
    *              Schedule STOP_ANGLE.
    **************************************************************************/
    _eTPU_thread INJ::IRQ_ANGLE(_eTPU_matches_disabled)
    {
    	/* prioritize Link service over Match service */
    	if(channel.LSR == 1) 
21B4: 0xF318FD67   seq  if SampledLinkServiceRequest==true then goto addr_0x1FAC, flush;;
    	{
    		Init_NoReturn();
    	}
        else
        {
    		/* Generate channel interrupt */
    		channel.CIRC = CIRC_INT_FROM_SERVICED;
21B8: 0xCFEF3A88   ram   p_23_0 = *((channel int24 *) 0x21);
    :              chan  set SvcdChan ChannelIntr;;
    
    		/* Schedule STOP_ANGLE */
    		ertb = tdc_angle_actual - angle_stop;
21BC: 0xBFE80B86   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x19);;
21C0: 0x1C193FFF   alu    ertB = a-p;;
    		channel.MRLB = MRL_CLEAR;
    		channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    		/* Channel flag */
    		channel.FLAG1 = INJ_FLAG1_STOP_ANGLE;
21C4: 0xF7FBCEFB   chan  set ChannelFlag1, clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;
    :              seq   end;;
    	}
    }
    
    
    DEFINE_ENTRY_TABLE(INJ, INJ, alternate, outputpin, autocfsr)
    {
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(6,7,   x,  x, x, x,  x, x, INIT),
010A: 0x07EB       Alt Entry 5, Addr 0x1FAC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==6,7    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 0,  x, x, INIT),
010C: 0x07EB       Alt Entry 6, Addr 0x1FAC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==0  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 1,  x, x, INIT),
010E: 0x07EB       Alt Entry 7, Addr 0x1FAC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==1  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR3(1,4,5, x,  x, x, x,  x, x, STOP),
0108: 0x0805       Alt Entry 4, Addr 0x2014, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==1,4,5  Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  0, x, UPDATE),
0100: 0x0815       Alt Entry 0, Addr 0x2054, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  1, x, UPDATE),
0102: 0x0815       Alt Entry 1, Addr 0x2054, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  0, x, UPDATE),
0104: 0x0815       Alt Entry 2, Addr 0x2054, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  1, x, UPDATE),
0106: 0x0815       Alt Entry 3, Addr 0x2054, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 0, START_ANGLE_1ST),
0110: 0x8817       Alt Entry 8, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 1, START_ANGLE_1ST),
0114: 0x8817       Alt Entry 10, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 0, START_ANGLE_1ST),
0118: 0x8817       Alt Entry 12, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 1, START_ANGLE_1ST),
011C: 0x8817       Alt Entry 14, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 0, START_ANGLE_1ST),
0130: 0x8817       Alt Entry 24, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 1, START_ANGLE_1ST),
0134: 0x8817       Alt Entry 26, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 0, START_ANGLE_1ST),
0138: 0x8817       Alt Entry 28, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 1, START_ANGLE_1ST),
013C: 0x8817       Alt Entry 30, Addr 0x205C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 0, PHASE),
0112: 0x084D       Alt Entry 9, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 1, PHASE),
0116: 0x084D       Alt Entry 11, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 0, PHASE),
011A: 0x084D       Alt Entry 13, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 1, PHASE),
011E: 0x084D       Alt Entry 15, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 0, PHASE),
0132: 0x084D       Alt Entry 25, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 1, PHASE),
0136: 0x084D       Alt Entry 27, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 0, PHASE),
013A: 0x084D       Alt Entry 29, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 1, PHASE),
013E: 0x084D       Alt Entry 31, Addr 0x2134, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 1, STOP_ANGLE_WHILE_ACTIVE),
0126: 0x084F       Alt Entry 19, Addr 0x213C, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 1, STOP_ANGLE_WHILE_ACTIVE),
012E: 0x084F       Alt Entry 23, Addr 0x213C, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 1, STOP_ANGLE_POST_ACTIVE),
0124: 0x0866       Alt Entry 18, Addr 0x2198, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 1, STOP_ANGLE_POST_ACTIVE),
012C: 0x0866       Alt Entry 22, Addr 0x2198, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 0, IRQ_ANGLE),
0120: 0x086D       Alt Entry 16, Addr 0x21B4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 0, IRQ_ANGLE),
0122: 0x086D       Alt Entry 17, Addr 0x21B4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 0, IRQ_ANGLE),
0128: 0x086D       Alt Entry 20, Addr 0x21B4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 0, IRQ_ANGLE),
012A: 0x086D       Alt Entry 21, Addr 0x21B4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    
        // unused/invalid entries
    };
    
    
    /*******************************************************************************
    *  Export interface information to Host CPU program. 
    *******************************************************************************/
    /* [MISRA 2004 Rule 3.4] usage of #pragma write documented in the Pragma Write 
       Manual, see https://www.ashware.com/Manuals */
    #pragma write h, (::ETPUfilename (cpu/etpu_inj_auto.h));
    #pragma write h, (/**************************************************************** );
    #pragma write h, (* WARNING: This file is automatically generated. DO NOT EDIT IT! );
    #pragma write h, (*);
    #pragma write h, (* FILE NAME: etpu_inj_auto.h  );
    #if defined(__TARGET_ETPU1__)
    #pragma write h, (* ARCHITECTURE: eTPU );
    #else
    #pragma write h, (* ARCHITECTURE: eTPU2 );
    #endif
    #pragma write h, (*);
    #pragma write h, (* This file was generated by: __FILE__ on __DATE__, __TIME__ );
    #pragma write h, (*);
    #pragma write h, (* This file provides an interface between eTPU code and CPU       );
    #pragma write h, (* code. All references to the eTPU function should be made with   );
    #pragma write h, (* information in this file. This allows only symbolic             );
    #pragma write h, (* information to be referenced which allows the eTPU code to be   );
    #pragma write h, (* optimized without effecting the CPU code.                       );
    #pragma write h, (*****************************************************************/);
    #pragma write h, (#ifndef _ETPU_INJ_AUTO_H_ );
    #pragma write h, (#define _ETPU_INJ_AUTO_H_ );
    #pragma write h, ( );
    #pragma write h, (/* Function Configuration Information */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_FUNCTION_NUMBER) ::ETPUfunctionnumber(INJ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_TABLE_SELECT) ::ETPUentrytype(INJ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_NUM_PARMS) ::ETPUram(INJ) );
    #pragma write h, ( );
    #pragma write h, (/* Host Service Request Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_HSR_INIT)         INJ_HSR_INIT );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_HSR_UPDATE)       INJ_HSR_UPDATE );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_HSR_STOP)         INJ_HSR_STOP );
    #pragma write h, ( );
    #pragma write h, (/* Function Mode Bit Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_FM0_ACTIVE_HIGH)  (INJ_FM0_ACTIVE_HIGH) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_FM0_ACTIVE_LOW)   (INJ_FM0_ACTIVE_LOW) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_FM1_CHANNEL_INJ)  ((INJ_FM1_CHANNEL_INJ<<1)) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_FM1_CHANNEL_BANK) ((INJ_FM1_CHANNEL_BANK<<1)) );
    #pragma write h, ( );
    #pragma write h, (/* Parameter Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_INJECTION_COUNT)   ::ETPUlocation (INJ, injection_count) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_INJECTION_COUNTER) ::ETPUlocation (INJ, injection_counter) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_PHASE_COUNTER)     ::ETPUlocation (INJ, phase_counter) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_ERROR)             ::ETPUlocation (INJ, error) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_INACTIVE_POLARITIES) ::ETPUlocation (INJ, inactive_polarities) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_BANK_CHANS_COUNT)  ::ETPUlocation (INJ, bank_chan_count) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_BANK_CHANS)        ::ETPUlocation (INJ, bank_chans) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_BANK_CHANS_MASK)   ::ETPUlocation (INJ, bank_chans_mask) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_P_INJECTION_FIRST) ::ETPUlocation (INJ, p_injection_first) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_P_INJECTION)       ::ETPUlocation (INJ, p_injection) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_P_PHASE)           ::ETPUlocation (INJ, p_phase) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_ANGLE_IRQ)         ::ETPUlocation (INJ, angle_irq) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_ANGLE_STOP)        ::ETPUlocation (INJ, angle_stop) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_TDC_ANGLE)         ::ETPUlocation (INJ, tdc_angle) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_TDC_ANGLE_ACTUAL)  ::ETPUlocation (INJ, tdc_angle_actual) );
    #pragma write h, ( );
    #pragma write h, (/* Global Variable Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_ACTIVE_BANK_CHANS) ::ETPUlocation (inj_global.active_bank_chans) );
    #pragma write h, ( );
    #pragma write h, (/* Injection Structure Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_PHASE_COUNT)   0x00 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_P_PHASE_FIRST) 0x01 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_ANGLE_START)   0x05 );
    #pragma write h, ( );
    #pragma write h, (/* Phase Structure Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_DMAS_OUTPUTS)    0x00 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_OFFSET_DURATION)        0x01 );
    #pragma write h, ( );
    #pragma write h, (/* Value Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_INJECTION_STRUCT_SIZE)  0x08 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_PHASE_STRUCT_SIZE)      0x04 );
    #pragma write h, ( );
    #pragma write h, (/* Error Flags Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_ERROR_PREV_INJ_NOT_FINISHED) INJ_ERROR_PREV_INJ_NOT_FINISHED);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_ERROR_LATE_START_ANGLE_1ST)  INJ_ERROR_LATE_START_ANGLE_1ST);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_ERROR_LATE_START_ANGLE_NTH)  INJ_ERROR_LATE_START_ANGLE_NTH);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_INJ_ERROR_STOPPED_BY_STOP_ANGLE) INJ_ERROR_STOPPED_BY_STOP_ANGLE);
    #pragma write h, ( );
    #pragma write h, (#endif );
    
    /*********************************************************************
     *
     * Copyright:
     *	Freescale Semiconductor, INC. All Rights Reserved.
     *  You are hereby granted a copyright license to use, modify, and
     *  distribute the SOFTWARE so long as this entire notice is
     *  retained without alteration in any modified and/or redistributed
     *  versions, and that such modified versions are clearly identified
     *  as such. No licenses are granted by implication, estoppel or
     *  otherwise under any patents or trademarks of Freescale
     *  Semiconductor, Inc. This software is provided on an "AS IS"
     *  basis and without warranty.
     *
     *  To the maximum extent permitted by applicable law, Freescale
     *  Semiconductor DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
     *  INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
     *  PARTICULAR PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH
     *  REGARD TO THE SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
     *  AND ANY ACCOMPANYING WRITTEN MATERIALS.
     *
     *  To the maximum extent permitted by applicable law, IN NO EVENT
     *  SHALL Freescale Semiconductor BE LIABLE FOR ANY DAMAGES WHATSOEVER
     *  (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
     *  BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER
     *  PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
     *
     *  Freescale Semiconductor assumes no responsibility for the
     *  maintenance and support of this software
     ********************************************************************/
    
    /*******************************************************************************
    *
    *  REVISION HISTORY:
    *
    *  FILE OWNER: Milan Brejl [r54529]
    *  Revision 1.2  2018/09/12  nxa17216
    *  Bug fix: missing injection happening regularly with error 
    *  FS_ETPU_INJ_ERROR_LATE_START_ANGLE_1ST. Condition code for checking
    *  if it is not late for scheduling 1st injection at the start angle was fixed.
    *  
    *  Revision 1.1  2014/12/15  r54529
    *  Union INJ_32_BIT added to enable bank_chans_mask functionality over all 
    *  32 bits (thanks to AshWare).
    *  Bug fix: after engine stall the INJ channels were not correctly reset and
    *  not able to restart after resync. Handling link was fixed. 
    *
    *  Revision 1.0  2014/03/16  r54529
    *  Minor comment and formating improvements. MISRA compliancy check.
    *  Ready for eTPU Engine Control Library release 1.0.
    *
    *  Revision 0.2  2013/08/14  r54529
    *  ERROR_UPDATE_NOT_APPLIED removed, asynchronous update enabled.
    *  irq_angle can be anywhere before the stop_angle, even during the injection.
    *  On link (stall condition from Crank), the INJ is re-initialized.
    *  Workarounds removed. bank_chans_mask not functional for channels 24-31.
    *
    *  Revision 0.1  2012/11/12  r54529
    *  Initial version. 
    *  Includes compiler bug workarounds. eTPU2 version is not functional.
    *  bank_chans_mask not functional for channels 24-31.
    *
    *******************************************************************************/
