ETEC Tools V3.00A                  ASH WARE Inc.                  (C) 2015-2020
    /*******************************************************************************
    * This file has been modified by ASH WARE Inc. as allowed per the original 
    * license (see bottom of file), to add features and fix issues.
    *******************************************************************************/
    
    /*******************************************************************************
    *
    *  FREESCALE SEMICONDUCTOR INC. 2008-2014
    *  ALL RIGHTS RESERVED
    *  COPYRIGHT (c)
    *
    ********************************************************************************
    *
    *  FILE NAME:  etpuc_spark.c
    *
    *  DESCRIPTION:
    *    This eTPU function is intended to generate ignition spark pulses 
    *    in an engine control system.
    *    
    *    A single spark consists of one or more pulses. 
    *    The first pulse is the main spark pulse, which is defined by dwell_time
    *    and end_angle. The main pulse start angle is estimated based on the current
    *    engine speed (using TRR register) and recalculated one again at the 
    *    angle_offset_recalc before the start angle. Whatever the acceleration or 
    *    deceleration is, the spark main pulse end_angle is kept and 
    *    dwell_time_applied varies, until the dwell_time_min or dwell_time_max must
    *    limitation is applied. In that case the end_angle is not kept and an
    *    error flag is set to report this.
    *    Multi spark pulses can follow the main spark pulse. They are defined by
    *    multi_on_time, multi_off_time and multi_pulse_count.
    *    
    *    The number of single sparks per engine cycle is configurable. The single
    *    sparks are defined by an array of single spark structures, consisting of
    *    end angle, dwell time and count of multi pulses.
    *    
    *    There is an SPARK parameter tdc_angle, relative to which all end angles are 
    *    defined. Positive angles precede the tdc_angle, negative angles come after.
    *    
    *    The SPARK function generates channel interrupts at each Recalculation Angle
    *    thread - angle_offset_recalc before the estimated start angle.
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  Includes
    *******************************************************************************/
    #include <etpu_std.h>
    #include "etpuc_spark.h"
    #include "etpuc_crank.h"   /* global eng_cycle_tcr2_ticks */
    #include "etpuc_set.h"
    
    /*******************************************************************************
    *  eTPU Function Parameters:
    *  
    *  SPARK Channel Parameters (struct SPARK_CHAN_PARAMS)
    *  ---------------------------------------------------
    *  tdc_angle - TCR2 angle relative to engine-cycle start
    *  tdc_angle_actual - absolute TDC TCR2 angle
    *  angle_offset_recalc - TCR2 angle offset between the start angle to 
    *    the recalculation point
    *  dwell_time_min - TCR1 minimum spark dwell time  
    *  dwell_time_max - TCR1 maximum spark dwell time
    *  multi_on_time - TCR time of multi spark pulse active state  
    *  multi_off_time - TCR time of multi spark pulse inactive state
    *  *p_single_spark_first - pointer to the first single spark structure  
    *  spark_count - count of single sparks per engine cycle      
    *  *p_single_spark - pointer to the current single spark structure
    *  spark_counter - counts single sparks
    *  pulse_start_time - captured TCR1 time of last spark main pulse start
    *  dwell_time_applied - applied TCR1 dwell time. It can slightly differ
    *    from dwell_time due to acceleration or deceleration. At corner cases,
    *    it is limited by dwell_time_min and dwell_time_max.
    *  dwell_time - copy of current TCR1 dwell time from single spark structure      
    *  end_angle - copy of current TCR2 end angle from single spark structure
    *  multi_pulse_count - copy of current count of multi pulses from single 
    *    spark structure     
    *  multi_pulse_counter - counts multi pulses      
    *  state - status, which angle/time event is scheduled
    *  error - error flags
    *  generation_disable - disable/enable injection pulse generation. A value
    *    change is applied from next recalculation angle, finishing the current
    *    engine-cycle unaffected.
    *    
    *  Single Spark Structure Parameters (struct SINGLE_SPARK)
    *  -------------------------------------------------------
    *  multi_pulse_count - count of multi pulses after the main spark pulse
    *  end_angle - TCR2 angle of the spark main pulse end
    *  dwell_time - TCR1 time of the spark dwell (spark main pulse width)
    *
    ********************************************************************************
    *
    *  Channel Flag usage
    *    Flag0 = SPARK_FLAG0_MAIN_PULSE (0)        ... Main pulse is active
    *    Flag0 = SPARK_FLAG0_OUT_OF_MAIN_PULSE (1) ... Main Pulse is not active
    *    Flag1 = SPARK_FLAG1_PRE_MIN_DWELL (0)     ... Prior to MIN_DWELL.
    *    Flag1 = SPARK_FLAG1_POST_MIN_DWELL (1)    ... Post to MIN_DWELL.
    *
    ********************************************************************************
    *
    *  Channel Function Mode (FM) bits usage
    *    FM0 is used to select the output polarity:
    *      - SPARK_FM0_ACTIVE_HIGH
    *      - SPARK_FM0_ACTIVE_LOW
    *    FM1 is not used.
    *
    ********************************************************************************
    *
    *  Channel Interrupt usage
    *    The channel interrupt on the SPARK channel is set on each RECALC_ANGLE. 
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  eTPU Class Methods/Fragments
    *******************************************************************************/
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleNextRecalcAngle_NoReturn
    *  DESCRIPTION: Schedule next RECALC_ANGLE
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleNextRecalcAngle_NoReturn(void)
    {
    	/* Increment spark pointer and counter */
    	p_single_spark++;
2360: 0xBFEFFB88   ram   p_23_0 = *((channel int24 *) 0x21);;
2364: 0x00287419   alu    p = p+0x8;;
2368: 0xBFFFFB88   ram   *((channel int24 *) 0x21) = p_23_0;;
    	spark_counter++;
236C: 0xCFEFF981   ram   p_31_24 = *((channel int8 *) 0x4);;
2370: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
2374: 0xCFFFF981   ram   *((channel int8 *) 0x4) = p_31_24;;
    	/* Engine-cycle finished? */
    	if(spark_counter >= spark_count)
2378: 0x00020419   alu    a = p_31_24+0x0;;
237C: 0xCFEFF980   ram   p_31_24 = *((channel int8 *) 0x0);;
2380: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
2384: 0xF4D11D07   seq  if LowerOrEqual==false then goto addr_0x23A0, flush;;
    	{
    		/* Reset spark pointer and counter */
    		p_single_spark = p_single_spark_first;
2388: 0xBFEFFF87   ram   diob = *((channel int24 *) 0x1D);;
238C: 0xBFFFFF88   ram   *((channel int24 *) 0x21) = diob;;
    		spark_counter = 0;
2390: 0xCFFFF901   ram   *((channel int8 *) 0x4) =  0;;
    		/* Update actual TDC angle for next cycle */
    		tdc_angle_actual += eng_cycle_tcr2_ticks;
2394: 0x9FEFFB00   ram   p_23_0 = *((global int24 *) 0x1);;
2398: 0xBFEFFF81   ram   diob = *((channel int24 *) 0x5);;
239C: 0xBF1B4F81   alu    diob = diob+p;
    :              ram   *((channel int24 *) 0x5) = diob;;
    	}
    
    	/* Read next spark parameters */
    	ReadSparkParams();
23A0: 0xFFD12507   seq  call addr_0x24A0, flush;;
    
    	/* Spark state */
    	state = SPARK_STATE_RECALC;
23A4: 0xCFF8F904   ram   *((channel int8 *) 0x10) =  0;
    :              chan  clear ChannelFlag0;;
    	
    	/* Channel flags */
    	channel.FLAG0 = SPARK_FLAG0_OUT_OF_MAIN_PULSE;
    	channel.FLAG1 = SPARK_FLAG1_POST_MIN_DWELL;
23A8: 0xCFEAF987   ram   p_31_24 = *((channel int8 *) 0x1C);
    :              chan  clear ChannelFlag1;;
    	
    	/* schedule the recalc */
    	is_first_recalc = TRUE;
23AC: 0x0C02ABA2   alu    p_31_24 = p_31_24 | 0x1;;
23B0: 0xCFFFF987   ram   *((channel int8 *) 0x1C) = p_31_24;;
    	angle_offset_recalc_working = angle_offset_recalc;
23B4: 0xBFEFFF82   ram   diob = *((channel int24 *) 0x9);;
    	ScheduleRecalcAngle_NoReturn();
23B8: 0xF7F11E07   seq  goto addr_0x23C0, no_flush;;
23BC: 0xBFFFFF8D   ram   *((channel int24 *) 0x35) = diob;;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleRecalcAngle_NoReturn
    *  DESCRIPTION: Schedule RECALC_ANGLE with current settings
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleRecalcAngle_NoReturn(void)
    {
    	int24_t tmp;
    
    	/* Calculate start angle */
    	tmp = dwell_time;
23C0: 0xBFEFFB8B   ram   p_23_0 = *((channel int24 *) 0x2D);;
    	tmp = CRANK_Time_to_Angle_LowRes(tmp);
23C4: 0xFFF056A7   seq  call addr_0xAD4, no_flush;;
23C8: 0x00080419   alu    a = p+0x0;;
23CC: 0xBFE91F81   alu    sr = a+0x0;
    :              ram   diob = *((channel int24 *) 0x5);;
    	ertb = tdc_angle_actual - end_angle - tmp;
23D0: 0xBFEFFB8C   ram   p_23_0 = *((channel int24 *) 0x31);;
23D4: 0xBC0B0B8D   alu    a = diob-p;
    :              ram   p_23_0 = *((channel int24 *) 0x35);;
23D8: 0x1C593FFF   alu    ertB = a-sr;;
    	ertb = ertb - angle_offset_recalc_working;
23DC: 0x1C133FFF   alu    ertB = ertB-p;;
    
    	/* Configure action unit */
    	channel.PDCM = PDCM_EM_NB_ST; /* either match non-blocking single transition */
    	channel.TBSB = TBS_M2C1GE;
    	channel.OPACB = OPAC_NO_CHANGE;
    	/* Schedule next RECAL_ANGLE */
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
23E0: 0x471F1E85   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB, FutureOutputPin no change on matchB,
    :                    ActionUnitB: tcr2 >= match, capture tcr1, mode = either match non blocking single transition;
    :              seq   end;;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleStartAngle_NoReturn
    *  DESCRIPTION: Recalculate and schedule START_ANGLE.
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleStartAngle_NoReturn(void)
    {
    	int24_t tmp;
    
    	/* Re-Calculate start angle */
    	tmp = dwell_time;
23E4: 0xBFEFFB8B   ram   p_23_0 = *((channel int24 *) 0x2D);;
    	tmp = CRANK_Time_to_Angle_HighRes(tmp);
23E8: 0xFFF04807   seq  call addr_0x900, no_flush;;
23EC: 0x00080419   alu    a = p+0x0;;
23F0: 0xBFE91F81   alu    sr = a+0x0;
    :              ram   diob = *((channel int24 *) 0x5);;
    	ertb = tdc_angle_actual - end_angle - tmp;
23F4: 0xBFEFFB8C   ram   p_23_0 = *((channel int24 *) 0x31);;
23F8: 0x1C1B0FFF   alu    a = diob-p;;
23FC: 0x1C593FFF   alu    ertB = a-sr;;
    
    	/* Configure action unit */
    	channel.TBSB = TBS_M2C1GE;
    	if(cc.FM0 == SPARK_FM0_ACTIVE_HIGH)
2400: 0xF3F12087   seq  if FunctionMode0==false then goto addr_0x2410, no_flush;;
2404: 0x4FFF1FFF   chan  ActionUnitB: tcr2 >= match, capture tcr1;;
    	{
    		channel.OPACB = OPAC_MATCH_HIGH;
    	}
2408: 0xF7F120A7   seq  goto addr_0x2414, no_flush;;
240C: 0x4F3FFFFF   chan  FutureOutputPin high on matchB;;
    	else
    	{
    		channel.OPACB = OPAC_MATCH_LOW;
2410: 0x4F5FFFFF   chan  FutureOutputPin low on matchB;;
    	}
    	/* Schedule START_ANGLE */
    	channel.MRLB = MRL_CLEAR;
2414: 0x7DFFAF9F   alu    p_31_24 = ((u24) 0)+0x1;
    :              chan  clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    	
    	/* Spark state */
    	state = SPARK_STATE_START;
2418: 0xCFF8F984   ram   *((channel int8 *) 0x10) = p_31_24;
    :              chan  clear ChannelFlag0;;
    
    	/* Channel flags */
    	channel.FLAG0 = SPARK_FLAG0_OUT_OF_MAIN_PULSE;
    	channel.FLAG1 = SPARK_FLAG1_PRE_MIN_DWELL;
241C: 0xF7FBFEF9   chan  set ChannelFlag1;
    :              seq   end;;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleMinDwellTime_NoReturn
    *  DESCRIPTION: Schedule MIN_DWELL_TIME to match A.
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleMinDwellTime_NoReturn(void)
    {
    	/* Configure action units */
    	channel.PDCM = PDCM_SM_ST;
    	channel.TBSA = TBS_M1C1GE;
    	channel.TBSB = TBS_M2C2GE; /* capture TCR2 on action unit B in order to check for min dwell conditions */
    	channel.OPACA = OPAC_NO_CHANGE;
    	if(cc.FM0 == SPARK_FM0_ACTIVE_HIGH)
2420: 0xF3F12187   seq  if FunctionMode0==false then goto addr_0x2430, no_flush;;
2424: 0x48F03FF9   chan  FutureOutputPin no change on matchA, ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr2 >= match, capture tcr2, mode = single match single transition;;
    	{
    		channel.OPACB = OPAC_MATCH_LOW;
    	}
2428: 0xF7F121A7   seq  goto addr_0x2434, no_flush;;
242C: 0x4F5FFFFF   chan  FutureOutputPin low on matchB;;
    	else
    	{
    		channel.OPACB = OPAC_MATCH_HIGH;
2430: 0x4F3FFFFF   chan  FutureOutputPin high on matchB;;
    	}
    	/* Schedule MIN_DWELL */
    	erta = pulse_start_time + dwell_time_min;
2434: 0xB1EFAB89   alu    p_31_24 = ((u24) 0)+0x2;
    :              ram   p_23_0 = *((channel int24 *) 0x25);;
2438: 0xCFE9FE83   ram   diob = *((channel int24 *) 0xD);
    :              chan  set ChannelFlag0;;
243C: 0x7F782E3F   alu    ertA = p+diob;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, clear MatchRecognitionLatchB;;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    
    	/* Spark state */
    	state = SPARK_STATE_MIN_DWELL;
    
    	/* Channel flags */
    	channel.FLAG0 = SPARK_FLAG0_MAIN_PULSE;
    	channel.FLAG1 = SPARK_FLAG1_PRE_MIN_DWELL;
2440: 0xC7FBF984   ram   *((channel int8 *) 0x10) = p_31_24;
    :              chan  set ChannelFlag1;
    :              seq   end;;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleEndAngleAndMaxDwellTime_NoReturn
    *  DESCRIPTION: Schedule MAX_DWELL_TIME to match A and END_ANGLE on B.
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleEndAngleAndMaxDwellTime_NoReturn(void)
    {
    	/* Configure action unit */
    	channel.PDCM = PDCM_EM_B_ST; /* either match blocking single transition */
    	channel.TBSA = TBS_M1C1GE;   /* match on TCR1, capture TCR1, greater-equal */
    	channel.TBSB = TBS_M2C1GE;
    	if(cc.FM0 == SPARK_FM0_ACTIVE_HIGH)
2444: 0xF3F122A7   seq  if FunctionMode0==false then goto addr_0x2454, no_flush;;
2448: 0x4FF01FE1   chan  ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr2 >= match, capture tcr1, mode = either match blocking single transition;;
    	{
    		channel.OPACA = OPAC_MATCH_LOW;
    	}
244C: 0xF7F122C7   seq  goto addr_0x2458, no_flush;;
2450: 0x4AFFFFFF   chan  FutureOutputPin low on matchA;;
    	else
    	{
    		channel.OPACA = OPAC_MATCH_HIGH;
2454: 0x49FFFFFF   chan  FutureOutputPin high on matchA;;
    	}
    	/* Schedule MAX_DWELL */
    	erta = pulse_start_time + dwell_time_max;
2458: 0xCFE9FA89   ram   p_23_0 = *((channel int24 *) 0x25);
    :              chan  set ChannelFlag0;;
245C: 0xBFE80B84   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x11);;
2460: 0x7F192E7F   alu    ertA = a+p;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA;;
    	channel.MRLA = MRL_CLEAR;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    	/* Schedule END_ANGLE */
    	ertb = tdc_angle_actual - end_angle;
2464: 0xCFEAFE81   ram   diob = *((channel int24 *) 0x5);
    :              chan  clear ChannelFlag1;;
2468: 0xBFEFFB8C   ram   p_23_0 = *((channel int24 *) 0x31);;
246C: 0x7C1B3F9F   alu    ertB = diob-p;
    :              chan  clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    
    	/* Spark state */
    	state = SPARK_STATE_MAX_DWELL;
2470: 0x000FA479   alu    p_31_24 = ((u24) 0)+0x3;;
2474: 0xC7FFF984   ram   *((channel int8 *) 0x10) = p_31_24;
    :              seq   end;;
    
    	/* Channel flags */
    	channel.FLAG0 = SPARK_FLAG0_MAIN_PULSE;
    	channel.FLAG1 = SPARK_FLAG1_POST_MIN_DWELL;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ScheduleMultiPulse_NoReturn
    *  DESCRIPTION: Schedule MULTI_PULSE.
    *               Note: End time of last pulse (either the main pulse or the 
    *               previous multi pulse) must be in erta register.
    *******************************************************************************/
    _eTPU_fragment SPARK::ScheduleMultiPulse_NoReturn(void)
    {
    	/* Configure action unit */
    	channel.PDCM = PDCM_BM_ST; /* both match single transition */
    	channel.TBSA = TBS_M1C1GE;
    	channel.TBSB = TBS_M1C1GE;
    	if(cc.FM0 == SPARK_FM0_ACTIVE_HIGH)
2478: 0xF3F12447   seq  if FunctionMode0==false then goto addr_0x2488, no_flush;;
247C: 0x4FF00FED   chan  ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr1 >= match, capture tcr1, mode = both match single transition;;
    	{
    		channel.OPACA = OPAC_MATCH_LOW;
    		channel.OPACB = OPAC_MATCH_HIGH;
    	}
2480: 0xF7F12467   seq  goto addr_0x248C, no_flush;;
2484: 0x4A3FFFFF   chan  FutureOutputPin low on matchA, FutureOutputPin high on matchB;;
    	else
    	{
    		channel.OPACA = OPAC_MATCH_HIGH;
2488: 0x495FFFFF   chan  FutureOutputPin high on matchA, FutureOutputPin low on matchB;;
    		channel.OPACB = OPAC_MATCH_LOW;
    	}
    	/* Schedule MULTI_PULSE */
    	ertb = erta + multi_off_time;
248C: 0xCFE8FA86   ram   p_23_0 = *((channel int24 *) 0x19);
    :              chan  clear ChannelFlag0;;
2490: 0xBF0E3B85   alu    ertB = ertA+p;
    :              ram   p_23_0 = *((channel int24 *) 0x15);;
    	erta = ertb + multi_on_time;
2494: 0x7F132E1F   alu    ertA = ertB+p;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    	channel.MRLB = MRL_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    
    	/* Spark state */
    	state = SPARK_STATE_MULTI_PULSE;
2498: 0x0C1FAF1E   alu    p_31_24 = ((u24) 0)+0x4;
    :              chan  clear ChannelFlag1;;
249C: 0xC7FFF984   ram   *((channel int8 *) 0x10) = p_31_24;
    :              seq   end;;
    
    	/* Channel flags */
    	channel.FLAG0 = SPARK_FLAG0_OUT_OF_MAIN_PULSE;
    	channel.FLAG1 = SPARK_FLAG1_POST_MIN_DWELL;
    }
    
    /*******************************************************************************
    *  FUNCTION NAME: ReadSparkParams
    *  DESCRIPTION: Coherently read single spark parameters to internal variables.
    *******************************************************************************/
    void SPARK::ReadSparkParams(void)
    {
    	/* semi-assembly code for coherent read from spark array */
    #ifdef __ETEC__
    	register_p31_24 p31_24;
        register_diob diob = (int24_t)p_single_spark;
24A0: 0xBFEFFF88   ram   diob = *((channel int24 *) 0x21);;
        NOP();
24A4: 0x4FFFFFFF   nop;;
    	/* [MISRA 2004 Rule 2.1] Assembly language shall be encapsulated and isolated */
    #asm
        ram p31_0 <- by diob++.
24A8: 0xFFEFF899   ram   p_31_0 = *((int32 *) diob++);;
        ram diob <- by diob; alu erta = p.
24AC: 0x1FE82FDF   alu    ertA = p+0x0;
    :              ram   diob = *((int24 *) diob);;
        alu ertb = diob.
24B0: 0x000B3419   alu    ertB = diob+0x0;;
    #endasm
    #else
    	register_p31_24 int8_t p31_24;
    	register_diob   int24_t diob;
    
    	diob = (int24_t)p_single_spark;
    	/* [MISRA 2004 Rule 2.1] Assembly language shall be encapsulated and isolated */
    	asm{
    		nop
    		ld p31_0,*diob++              /* first coherent read - end_angle and multi_pulse_count*/ 
    		move ert_a,p; ld diob,*diob   /* second coherent read - dwell_time */
    		move ert_b,diob
    	};
    #endif
    	multi_pulse_count = p31_24;
24B4: 0xCFFFF982   ram   *((channel int8 *) 0x8) = p_31_24;;
    	end_angle = erta;
24B8: 0xBFFE7B8C   alu    p = ertA+0x0;
    :              ram   *((channel int24 *) 0x31) = p_23_0;;
    	dwell_time = ertb;
    }
24BC: 0xFFFFCEF9   seq  return, no_flush;;
24C0: 0xBFF37B8B   alu    p = ertB+0x0;
    :              ram   *((channel int24 *) 0x2D) = p_23_0;;
    
    
    /*******************************************************************************
    *  eTPU Function
    *******************************************************************************/
    
    /**************************************************************************
    * THREAD NAME: INIT
    * DESCRIPTION: Initialize the channel to run the SPARK function.
    **************************************************************************/
    _eTPU_thread SPARK::INIT(_eTPU_matches_disabled)
    {
    	/* Stop the channel */
    	/* Disable event handling */
    	channel.MTD = MTD_DISABLE;
24C4: 0xFB77FEFB   chan  clear TransitionDetectionLatches, clear MatchEnableLatches, DisableMatchTransitionServicing;;
    	/* Disable match detection */
    	channel.MRLE = MRLE_DISABLE;
    	/* Reset all latches */
    	channel.TDL = TDL_CLEAR;
    	channel.LSR = LSR_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    
    	/* Initialize the channel */
    	/* Input pin action control */
    	channel.IPACA = IPAC_NO_DETECT;
    	channel.IPACB = IPAC_NO_DETECT;
    	/* Enable output pin buffer */
    	channel.TBSA = TBSA_SET_OBE;
    
    	/* Set the pin to the inactive state */
    	if(cc.FM0 == SPARK_FM0_ACTIVE_HIGH)
24C8: 0xF3F126C7   seq  if FunctionMode0==false then goto addr_0x24D8, no_flush;;
24CC: 0x5818F6BF   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, enable output buffer, clear LinkServiceRequest, detectA = off, detectB = off;;
    	{
    		channel.PIN = PIN_SET_LOW;
    	}
24D0: 0xF7F126E7   seq  goto addr_0x24DC, no_flush;;
24D4: 0x7FFFFDFE   chan  CurrentOutputPin = low;;
    	else
    	{
    		channel.PIN = PIN_SET_HIGH;
24D8: 0x7FFFFBFE   chan  CurrentOutputPin = high;;
    	}				
    
    	/* Initialize spark counter so that it is reset in ScheduleNextRecalAngle_NoReturn() */
    	spark_counter = spark_count;
24DC: 0xDF3FF981   ram   *((channel int8 *) 0x4) = p_31_24;
    :              chan  EnableMatchTransitionServicing;;
    	/* Initialize actual TDC angle (eng_cycle_tcr2_ticks is added in ScheduleNextRecalAngle_NoReturn()) */
    	tdc_angle_actual = eng_cycle_tcr2_start + tdc_angle - eng_cycle_tcr2_ticks;
24E0: 0x9FE80B01   alu    a = p+0x0;
    :              ram   p_23_0 = *((global int24 *) 0x5);;
24E4: 0x9F280B00   alu    a = p+a;
    :              ram   p_23_0 = *((global int24 *) 0x1);;
24E8: 0xBC197B81   alu    p = a-p;
    :              ram   *((channel int24 *) 0x5) = p_23_0;;
    	
    	/* Enable event handling */
    	channel.MTD = MTD_ENABLE;
    
        if (eng_pos_state != ENG_POS_FULL_SYNC)
24EC: 0xCFEFF100   ram   p_31_24 = *((global int8 *) 0x0);;
24F0: 0x0802FBEA   alu    nil = p_31_24 ^ 0x3, SampleFlags;;
24F4: 0xF0D91B07   seq  if z==true then goto addr_0x2360, flush;;
        {
            /* only fully start the spark processing once sync is achieved */
            return;
24F8: 0x0FFFFFFF   seq   end;;
        }
    
    	/* Schedule the first RECALC_ANGLE */
    	ScheduleNextRecalcAngle_NoReturn();
    }
    
    /**************************************************************************
    * THREAD NAME: UPDATE
    * DESCRIPTION: Spark parameters are updated. Apply the update as possible.
    **************************************************************************/
    _eTPU_thread SPARK::UPDATE(_eTPU_matches_disabled)
    {
    	/* Read updated spark parameters */
    	ReadSparkParams();
24FC: 0xFFD12507   seq  call addr_0x24A0, flush;;
    
    	/* Theoretically, the HSR_UPDATE can be serviced between a match and 
    	 * the match service. In this case let the match be serviced. */
    	if((cc.MRLA == 0) && (cc.MRLB == 0))
2500: 0xF2992A47   seq  if SampledMatchRecognitionLatchA==true then goto addr_0x2548, flush;;
2504: 0xF2D92A47   seq  if SampledMatchRecognitionLatchB==true then goto addr_0x2548, flush;;
    	{
    		switch(state)
2508: 0xCFEFF984   ram   p_31_24 = *((channel int8 *) 0x10);;
250C: 0x00020419   alu    a = p_31_24+0x0;;
2510: 0x1809D38A   alu    p_7_0 = a ^ 0x0, SampleFlags;;
2514: 0xF0D929A7   seq  if z==true then goto addr_0x2534, flush;;
2518: 0x0809DBAA   alu    p_7_0 = a ^ 0x1, SampleFlags;;
251C: 0xF0D91F27   seq  if z==true then goto addr_0x23E4, flush;;
2520: 0x0809DBCA   alu    p_7_0 = a ^ 0x2, SampleFlags;;
2524: 0xF0D929E7   seq  if z==true then goto addr_0x253C, flush;;
2528: 0x0809DBEA   alu    p_7_0 = a ^ 0x3, SampleFlags;;
252C: 0xF0D929E7   seq  if z==true then goto addr_0x253C, flush;;
2530: 0x0FFFFFFF   seq   end;;
    		{
    		case SPARK_STATE_RECALC:
                /* Read next spark parameters to get (possibly) updated values */
                ReadSparkParams();
2534: 0xFFD12507   seq  call addr_0x24A0, flush;;
    
    			/* Re-schedule RECALC_ANGLE */
    			ScheduleRecalcAngle_NoReturn();
2538: 0xF7D11E07   seq  goto addr_0x23C0, flush;;
    			break;
    
    		case SPARK_STATE_START:
    			/* Re-schedule START_ANGLE */
    			ScheduleStartAngle_NoReturn();
    			break;
    
    		case SPARK_STATE_MIN_DWELL:
    		case SPARK_STATE_MAX_DWELL:
    			/* Re-schedule END_ANGLE */
    			ertb = tdc_angle_actual - end_angle;
253C: 0xBFEFFF81   ram   diob = *((channel int24 *) 0x5);;
2540: 0xBFEFFB8C   ram   p_23_0 = *((channel int24 *) 0x31);;
2544: 0x7C1B3FDF   alu    ertB = diob-p;
    :              chan  matchB = ertB, set MatchEnableLatchB;;
    			channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    			break;
    		}
    	}
    }
2548: 0x0FFFFFFF   seq   end;;
    
    /**************************************************************************
    * THREAD NAME: RECALC_ANGLE
    * DESCRIPTION: Set channel interrupt.
    *              Check parameter values and schedule START_ANGLE.
    **************************************************************************/
    _eTPU_thread SPARK::RECALC_ANGLE(_eTPU_matches_disabled)
    {
        if (is_first_recalc)
254C: 0xCFEFF987   ram   p_31_24 = *((channel int8 *) 0x1C);;
2550: 0xF5112B67   seq  if p.bit(24)==false then goto addr_0x256C, flush;;
        {
            /* channel interrupt */
            channel.CIRC = CIRC_INT_FROM_SERVICED;
2554: 0xCFEF3A8D   ram   p_23_0 = *((channel int24 *) 0x35);
    :              chan  set SvcdChan ChannelIntr;;
            
            is_first_recalc = FALSE;
2558: 0x0FF2ABD2   alu    p_31_24 = p_31_24 & 0xFFFFFE;;
255C: 0xCFFFF987   ram   *((channel int8 *) 0x1C) = p_31_24;;
            angle_offset_recalc_working >>= 2;
2560: 0x1C087B92   alu    p = p >> 2;;
            ScheduleRecalcAngle_NoReturn();
2564: 0xF7F11E07   seq  goto addr_0x23C0, no_flush;;
2568: 0xBFFFFB8D   ram   *((channel int24 *) 0x35) = p_23_0;;
        }
    
    	if((generation_disable == SPARK_GENERATION_ALLOWED) &&
    	   (dwell_time > 0))
256C: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
2570: 0x0002A019   alu    p_31_24 = p_31_24+0x0, SampleFlags;;
2574: 0xF0D11B07   seq  if z==false then goto addr_0x2360, flush;;
2578: 0xBFEFFB8B   ram   p_23_0 = *((channel int24 *) 0x2D);;
257C: 0x0008F019   alu    nil = p+0x0, SampleFlags;;
2580: 0xF0D91B07   seq  if z==true then goto addr_0x2360, flush;;
    	{
    		/* Schedule START_ANGLE */
    		ScheduleStartAngle_NoReturn();
2584: 0xF7D11F27   seq  goto addr_0x23E4, flush;;
    	}
    	else
    	{
    		/* Skip to next spark and schedule next RECALC_ANGLE */
    		ScheduleNextRecalcAngle_NoReturn();
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: START_ANGLE
    * DESCRIPTION: Store pulse start time.
    *              Schedule MIN_DWELL_TIME.
    **************************************************************************/
    _eTPU_thread SPARK::START_ANGLE(_eTPU_matches_disabled)
    {
    	/* Store pulse start time */
    	pulse_start_time = ertb;
    	
    	/* Schedule MIN_DWELL_TIME */
    	ScheduleMinDwellTime_NoReturn();
2588: 0xF7F12107   seq  goto addr_0x2420, no_flush;;
258C: 0xBFF34F89   alu    diob = ertB+0x0;
    :              ram   *((channel int24 *) 0x25) = diob;;
    }
    
    /**************************************************************************
    * THREAD NAME: MIN_DWELL_TIME
    * DESCRIPTION: Processing at min dwell time.
    **************************************************************************/
    _eTPU_thread SPARK::MIN_DWELL_TIME(_eTPU_matches_disabled)
    {
        /* check for min dwell conditions - if end angle came before this
         * min dwell match, flag it */
        if ((tdc_angle_actual - end_angle) - ertb <= 0)
2590: 0xBFE31B8C   alu    sr = ertB+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0x31);;
2594: 0x1C1B0FFF   alu    a = diob-p;;
2598: 0x1C590FFF   alu    a = a-sr;;
259C: 0x1C3FFEFF   alu    nil = ((u24) 0)-a, SampleFlags;;
25A0: 0xF4992227   seq  if LessThan==true then goto addr_0x2444, flush;;
        {
    		/* Set error */
    		error |= SPARK_ERROR_MIN_DWELL_APPLIED;
25A4: 0xCFEFF985   ram   p_31_24 = *((channel int8 *) 0x14);;
25A8: 0x0C02ABA2   alu    p_31_24 = p_31_24 | 0x1;;
        }
    
        /* Schedule END_ANGLE and MAX_DWELL_TIME */
        ScheduleEndAngleAndMaxDwellTime_NoReturn();
25AC: 0xF7F12227   seq  goto addr_0x2444, no_flush;;
25B0: 0xCFFFF985   ram   *((channel int8 *) 0x14) = p_31_24;;
    }
    
    /**************************************************************************
    * THREAD NAME: END_ANGLE
    * DESCRIPTION: Store applied dwell time.
    *              Start the multi pulse sequence or schedule next RECAL_ANGLE.
    **************************************************************************/
    _eTPU_thread SPARK::END_ANGLE(_eTPU_matches_disabled)
    {
    	/* Store applied dwell time */
    	dwell_time_applied = ertb - pulse_start_time;
25B4: 0xBFE2AA89   alu    p_31_24 = p_31_24+0x0, SampleFlags;
    :              ram   p_23_0 = *((channel int24 *) 0x25);;
    	
    	/* Multi-pulse sequence ? */
    	if(multi_pulse_count > 0)
25B8: 0xF0F91B07   seq  if z==true then goto addr_0x2360, no_flush;;
25BC: 0xBC134F8A   alu    diob = ertB-p;
    :              ram   *((channel int24 *) 0x29) = diob;;
    	{
    		/* Reset multi-pulse counter */
    		multi_pulse_counter = 0;
25C0: 0xCFFFF903   ram   *((channel int8 *) 0xC) =  0;;
    		/* Schedule the first MULTI_PULSE */
    		erta = ertb;
    		ScheduleMultiPulse_NoReturn();
25C4: 0xF7F123C7   seq  goto addr_0x2478, no_flush;;
25C8: 0x00032419   alu    ertA = ertB+0x0;;
    	}
    	else
    	{
    		/* Schedule next RECALC_ANGLE */
    		ScheduleNextRecalcAngle_NoReturn();
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: MAX_DWELL_TIME
    * DESCRIPTION: Store applied dwell time.
    *              Set error MAX_DWELL_APPLIED.
    *              Start the multi pulse sequence or schedule next RECAL_ANGLE.
    **************************************************************************/
    _eTPU_thread SPARK::MAX_DWELL_TIME(_eTPU_matches_disabled)
    {
    	/* Store applied dwell time */
    	dwell_time_applied = erta - pulse_start_time;
25CC: 0xBFEFFB89   ram   p_23_0 = *((channel int24 *) 0x25);;
25D0: 0xBC1E4F8A   alu    diob = ertA-p;
    :              ram   *((channel int24 *) 0x29) = diob;;
    	
    	/* Set error */
    	error |= SPARK_ERROR_MAX_DWELL_APPLIED;
25D4: 0xCFEFF985   ram   p_31_24 = *((channel int8 *) 0x14);;
25D8: 0x0C02ABC2   alu    p_31_24 = p_31_24 | 0x2;;
25DC: 0xCFFFF985   ram   *((channel int8 *) 0x14) = p_31_24;;
    	
    	/* Multi-pulse sequence ? */
    	if(multi_pulse_count > 0)
25E0: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
25E4: 0x0002A019   alu    p_31_24 = p_31_24+0x0, SampleFlags;;
25E8: 0xF0D91B07   seq  if z==true then goto addr_0x2360, flush;;
    	{
    		/* Reset multi-pulse counter */
    		multi_pulse_counter = 0;
    		/* Schedule the first MULTI_PULSE */
    		ScheduleMultiPulse_NoReturn();
25EC: 0xF7F123C7   seq  goto addr_0x2478, no_flush;;
25F0: 0xCFFFF903   ram   *((channel int8 *) 0xC) =  0;;
    	}
    	else
    	{
    		/* Schedule next RECALC_ANGLE */
    		ScheduleNextRecalcAngle_NoReturn();
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: MULTI_PULSE
    * DESCRIPTION: Schedule next MULTI_PULSE or RECAL_ANGLE.
    **************************************************************************/
    _eTPU_thread SPARK::MULTI_PULSE(_eTPU_matches_disabled)
    {
    	multi_pulse_counter++;
25F4: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
25F8: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
25FC: 0xCFFFF983   ram   *((channel int8 *) 0xC) = p_31_24;;
    	if(multi_pulse_counter < multi_pulse_count)
2600: 0x00020419   alu    a = p_31_24+0x0;;
2604: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
2608: 0x00021419   alu    sr = p_31_24+0x0;;
260C: 0x1C59AEFF   alu    p_31_24 = a-sr, SampleFlags;;
2610: 0xF0911B07   seq  if cFlag==false then goto addr_0x2360, flush;;
    	{
    		/* Schedule next MULTI_PULSE */
    		ScheduleMultiPulse_NoReturn();
2614: 0xF7D123C7   seq  goto addr_0x2478, flush;;
    	}
    	else
    	{
    		/* Schedule next RECALC_ANGLE */
    		ScheduleNextRecalcAngle_NoReturn();
    	}
    }
    
    
    DEFINE_ENTRY_TABLE(SPARK, SPARK, alternate, outputpin, autocfsr)
    {
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(6,7,   x,  x, x, x,  x, x, INIT),
018A: 0x0931       Alt Entry 5, Addr 0x24C4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==6,7    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 0,  x, x, INIT),
018C: 0x0931       Alt Entry 6, Addr 0x24C4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==0  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 1,  x, x, INIT),
018E: 0x0931       Alt Entry 7, Addr 0x24C4, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==1  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  0, x, UPDATE),
0180: 0x093F       Alt Entry 0, Addr 0x24FC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  1, x, UPDATE),
0182: 0x093F       Alt Entry 1, Addr 0x24FC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  0, x, UPDATE),
0184: 0x093F       Alt Entry 2, Addr 0x24FC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  1, x, UPDATE),
0186: 0x093F       Alt Entry 3, Addr 0x24FC, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 0, RECALC_ANGLE),
01A0: 0x0953       Alt Entry 16, Addr 0x254C, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 0, RECALC_ANGLE),
01A8: 0x0953       Alt Entry 20, Addr 0x254C, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 1, START_ANGLE),
01A4: 0x8962       Alt Entry 18, Addr 0x2588, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 1, START_ANGLE),
01AC: 0x8962       Alt Entry 22, Addr 0x2588, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 1, START_ANGLE),
01B4: 0x8962       Alt Entry 26, Addr 0x2588, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 1, START_ANGLE),
01BC: 0x8962       Alt Entry 30, Addr 0x2588, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 1, MIN_DWELL_TIME),
0196: 0x0964       Alt Entry 11, Addr 0x2590, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 1, MIN_DWELL_TIME),
019E: 0x0964       Alt Entry 15, Addr 0x2590, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 1, MIN_DWELL_TIME),
01B6: 0x0964       Alt Entry 27, Addr 0x2590, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 1, MIN_DWELL_TIME),
01BE: 0x0964       Alt Entry 31, Addr 0x2590, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 0, END_ANGLE),
01A2: 0x896D       Alt Entry 17, Addr 0x25B4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 0, END_ANGLE),
01AA: 0x896D       Alt Entry 21, Addr 0x25B4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 0, END_ANGLE),
01B2: 0x896D       Alt Entry 25, Addr 0x25B4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 0, END_ANGLE),
01BA: 0x896D       Alt Entry 29, Addr 0x25B4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 0, MAX_DWELL_TIME),
0192: 0x8973       Alt Entry 9, Addr 0x25CC, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 0, MAX_DWELL_TIME),
019A: 0x8973       Alt Entry 13, Addr 0x25CC, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 0, MULTI_PULSE),
01B0: 0x897D       Alt Entry 24, Addr 0x25F4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 0, MULTI_PULSE),
01B8: 0x897D       Alt Entry 28, Addr 0x25F4, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    
        // unused/invalid entries
    	ETPU_VECTOR3(1,4,5, x,  x, x, x,  x, x, _Error_handler_unexpected_thread),
0188: 0x09F4       Alt Entry 4, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==1,4,5  Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 0, _Error_handler_unexpected_thread),
0190: 0x09F4       Alt Entry 8, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 1, _Error_handler_unexpected_thread),
0194: 0x09F4       Alt Entry 10, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 0, _Error_handler_unexpected_thread),
0198: 0x09F4       Alt Entry 12, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 1, _Error_handler_unexpected_thread),
019C: 0x09F4       Alt Entry 14, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 1, _Error_handler_unexpected_thread),
01A6: 0x09F4       Alt Entry 19, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 1, _Error_handler_unexpected_thread),
01AE: 0x09F4       Alt Entry 23, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    };
    
    
    /*******************************************************************************
    *  Export interface information to Host CPU program.
    *******************************************************************************/
    /* [MISRA 2004 Rule 3.4] usage of #pragma write documented in the Pragma Write 
       Manual, see https://www.ashware.com/Manuals */
    #pragma write h, (::ETPUfilename (cpu/etpu_spark_auto.h));
    #pragma write h, (/**************************************************************** );
    #pragma write h, (* WARNING: This file is automatically generated. DO NOT EDIT IT! );
    #pragma write h, (*);
    #pragma write h, (* FILE NAME: etpu_spark.h  );
    #if defined(__TARGET_ETPU1__)
    #pragma write h, (* ARCHITECTURE: eTPU );
    #else
    #pragma write h, (* ARCHITECTURE: eTPU2 );
    #endif
    #pragma write h, (*);
    #pragma write h, (* This file was generated by: __FILE__ on __DATE__, __TIME__ );
    #pragma write h, (*);
    #pragma write h, (* This file provides an interface between eTPU code and CPU       );
    #pragma write h, (* code. All references to the eTPU function should be made with   );
    #pragma write h, (* information in this file. This allows only symbolic             );
    #pragma write h, (* information to be referenced which allows the eTPU code to be   );
    #pragma write h, (* optimized without effecting the CPU code.                       );
    #pragma write h, (*****************************************************************/);
    #pragma write h, (#ifndef _ETPU_SPARK_AUTO_H_ );
    #pragma write h, (#define _ETPU_SPARK_AUTO_H_ );
    #pragma write h, ( );
    #pragma write h, (/* Function Configuration Information */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_FUNCTION_NUMBER) ::ETPUfunctionnumber(SPARK) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_TABLE_SELECT) ::ETPUentrytype(SPARK) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_NUM_PARMS) ::ETPUram(SPARK) );
    #pragma write h, ( );
    #pragma write h, (/* Host Service Request Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_HSR_INIT)        SPARK_HSR_INIT );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_HSR_UPDATE)      SPARK_HSR_UPDATE );
    #pragma write h, ( );
    #pragma write h, (/* Function Mode Bit Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_FM0_ACTIVE_LOW)  SPARK_FM0_ACTIVE_LOW );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_FM0_ACTIVE_HIGH) SPARK_FM0_ACTIVE_HIGH );
    #pragma write h, ( );
    #pragma write h, (/* Parameter Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_TDC_ANGLE                 ) ::ETPUlocation (SPARK, tdc_angle ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_TDC_ANGLE_ACTUAL          ) ::ETPUlocation (SPARK, tdc_angle_actual ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_ANGLE_OFFSET_RECALC       ) ::ETPUlocation (SPARK, angle_offset_recalc ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_DWELL_TIME_MIN            ) ::ETPUlocation (SPARK, dwell_time_min ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_DWELL_TIME_MAX            ) ::ETPUlocation (SPARK, dwell_time_max ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_MULTI_ON_TIME             ) ::ETPUlocation (SPARK, multi_on_time ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_MULTI_OFF_TIME            ) ::ETPUlocation (SPARK, multi_off_time ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_P_SINGLE_SPARK_FIRST      ) ::ETPUlocation (SPARK, p_single_spark_first ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_P_SINGLE_SPARK            ) ::ETPUlocation (SPARK, p_single_spark ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_PULSE_START_TIME          ) ::ETPUlocation (SPARK, pulse_start_time ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_DWELL_TIME_APPLIED        ) ::ETPUlocation (SPARK, dwell_time_applied ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_DWELL_TIME                ) ::ETPUlocation (SPARK, dwell_time ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_END_ANGLE                 ) ::ETPUlocation (SPARK, end_angle ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_SPARK_COUNT               ) ::ETPUlocation (SPARK, spark_count ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_SPARK_COUNTER             ) ::ETPUlocation (SPARK, spark_counter ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_MULTI_PULSE_COUNT         ) ::ETPUlocation (SPARK, multi_pulse_count ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_MULTI_PULSE_COUNTER       ) ::ETPUlocation (SPARK, multi_pulse_counter ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_STATE                     ) ::ETPUlocation (SPARK, state ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_ERROR                     ) ::ETPUlocation (SPARK, error ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_OFFSET_GENERATION_DISABLE        ) ::ETPUlocation (SPARK, generation_disable ) );
    #pragma write h, ( );
    #pragma write h, (/* Error Flags Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_ERROR_MIN_DWELL_APPLIED)        SPARK_ERROR_MIN_DWELL_APPLIED);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_ERROR_MAX_DWELL_APPLIED)        SPARK_ERROR_MAX_DWELL_APPLIED);
    #pragma write h, ( );
    #pragma write h, (/* Generation Disable Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_GENERATION_ALLOWED)             SPARK_GENERATION_ALLOWED);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SPARK_GENERATION_DISABLED)            SPARK_GENERATION_DISABLED);
    #pragma write h, ( );
    #pragma write h, (/* Spark Structure Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SINGLE_SPARK_OFFSET_MULTI_PULSE_COUNT) 0x00 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SINGLE_SPARK_OFFSET_END_ANGLE)         0x01 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SINGLE_SPARK_OFFSET_DWELL_TIME)        0x05 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_SINGLE_SPARK_STRUCT_SIZE)              0x08 );
    #pragma write h, ( );
    #pragma write h, (#endif );
    
    /*********************************************************************
     *
     * Copyright:
     *	Freescale Semiconductor, INC. All Rights Reserved.
     *  You are hereby granted a copyright license to use, modify, and
     *  distribute the SOFTWARE so long as this entire notice is
     *  retained without alteration in any modified and/or redistributed
     *  versions, and that such modified versions are clearly identified
     *  as such. No licenses are granted by implication, estoppel or
     *  otherwise under any patents or trademarks of Freescale
     *  Semiconductor, Inc. This software is provided on an "AS IS"
     *  basis and without warranty.
     *
     *  To the maximum extent permitted by applicable law, Freescale
     *  Semiconductor DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
     *  INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
     *  PARTICULAR PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH
     *  REGARD TO THE SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
     *  AND ANY ACCOMPANYING WRITTEN MATERIALS.
     *
     *  To the maximum extent permitted by applicable law, IN NO EVENT
     *  SHALL Freescale Semiconductor BE LIABLE FOR ANY DAMAGES WHATSOEVER
     *  (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
     *  BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER
     *  PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
     *
     *  Freescale Semiconductor assumes no responsibility for the
     *  maintenance and support of this software
     ********************************************************************/
    
    /*******************************************************************************
    *
    *  REVISION HISTORY:
    *
    *  FILE OWNER: Milan Brejl [r54529]
    *  Revision 1.1  2020/08/14  nxa17216
    *  Added initialization of pin state into an inactive state within INIT thread.
    *  Revision 1.0  2014/03/16  r54529
    *  Minor comment and formating improvements. MISRA compliancy check.
    *  Ready for eTPU Engine Control Library release 1.0.
    *
    *  Revision 0.2  2013/09/05  r54529
    *  Generation disable added + minor updates.
    *
    *  Revision 0.1  2013/08/27  r54529
    *  Initial version.
    *
    *******************************************************************************/
