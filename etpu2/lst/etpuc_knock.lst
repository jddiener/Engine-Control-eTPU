ETEC Tools V3.00A                  ASH WARE Inc.                  (C) 2015-2020
    /*******************************************************************************
    * This file has been modified by ASH WARE Inc. as allowed per the original 
    * license (see bottom of file), to add features and fix issues.
    *******************************************************************************/
    
    /*******************************************************************************
    *
    *  FREESCALE SEMICONDUCTOR INC. 2013-2014
    *  ALL RIGHTS RESERVED
    *  COPYRIGHT (c)
    *
    ********************************************************************************
    *
    *  FILE NAME:  etpuc_knock.c
    *
    *  DESCRIPTION:
    *    This eTPU function is intended to support ADC sampling of a knock signal
    *    in an engine control system. 
    *    The function has 2 modes:
    *    - Gate mode
    *    - Trigger mode
    *    
    *    In the Gate mode a simple angle-based pulses are generated. The output
    *    signal can be used to gate the ADC, running in a continues mode.
    *    In the Trigger mode a 50% duty-cycle PWM signal is generated within
    *    the angle-based window. The output signal can be used to trigger the ADC.
    *    
    *    The number of angle-based windows is configurable. The windows are
    *    defined by an array of window structures, consisting of window start angle
    *    and angle windows width.
    *    
    *    There is an KNOCK parameter tdc_angle, relative to which all windows are 
    *    defined. Positive angles precede the tdc_angle, negative angles come after.
    *    
    *    The KNOCK function enables to selectively generate channel interrupts and/or
    *    DMA requests at:
    *    - window start
    *    - window end
    *    - every trigger pulse (Trigger mode only)
    *    
    *******************************************************************************/
    
    /*******************************************************************************
    *  Includes
    *******************************************************************************/
    #include <etpu_std.h>
    #include "etpuc_knock.h"
    #include "etpuc_crank.h"
    #include "etpuc_set.h"
    
    /*******************************************************************************
    *  eTPU Function Parameters:
    *
    *  KNOCK Channel Parameters (struct KNOCK_CHAN_PARAMS)
    *  -----------------------------------------------
    *  window_count - count of windows per engine cycle
    *  *p_window_first - pointer to the first knock window structure
    *  window_counter - counts knock windows
    *  *p_window - pointer to the current knock window structure
    *  tdc_angle - TCR2 angle relative to engine-cycle start
    *  tdc_angle_actual - absolute TDC TCR2 angle
    *  tcr2_window_start - absolute TCR2 window start angle
    *  tcr2_window_end - absolute TCR2 window end angle
    *  trigger_period - TCR1 trigger period
    *  irq_dma_options - IRQ and DMA request selection
    *
    *  Knock Window Structure Parameters (struct KNOCK_WINDOW)
    *  -----------------------------------------------------
    *  start - TDC-relative TCR2 angle start
    *  width - knock window TCR2 angle width
    *
    ********************************************************************************
    *
    *  Channel Flag usage
    *    Flag0 = KNOCK_FLAG0_WINDOW_NOT_ACTIVE (0)
    *    Flag0 = KNOCK_FLAG0_WINDOW_ACTIVE (1)
    *    Flag0 = KNOCK_FLAG1_MODE_GATE (0)     ... Operates in Gate mode
    *    Flag0 = KNOCK_FLAG1_MODE_TRIGGER (1)  ... Operates in Trigger mode
    *
    *******************************************************************************/
    
    
    /*******************************************************************************
    *  eTPU Class Methods/Fragments
    *******************************************************************************/
    
    /*******************************************************************************
    *  FUNCTION NAME: ReadWindow
    *  DESCRIPTION: Schedule the IRQ_ANGLE, set flag.
    *******************************************************************************/
    _eTPU_fragment KNOCK::ScheduleStartAngle_NoReturn(void)
    {
    	/* semi-assembly code for coherent read from knock window array */
        register_diob diob = (int24_t)p_window;
21D8: 0xBFEFFF81   ram   diob = *((channel int24 *) 0x5);;
        NOP();
21DC: 0x4FFFFFFF   nop;;
    	/* [MISRA 2004 Rule 2.1] Assembly language shall be encapsulated and isolated */
    #asm
        ram p <- by diob++.
21E0: 0x1FEFFB9F   ram   p_23_0 = *((int24 *) diob++);;
        ram p <- by diob; alu ertb = p.
21E4: 0x1FE83BDF   alu    ertB = p+0x0;
    :              ram   p_23_0 = *((int24 *) diob);;
        alu erta = p.
21E8: 0x00082419   alu    ertA = p+0x0;;
    #endasm
    
        /* Calculate absolute TCR2 angles */
    	ertb = tdc_angle_actual - ertb;
21EC: 0xBFE31B83   alu    sr = ertB+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0xD);;
21F0: 0x7C583F9F   alu    ertB = p-sr;
    :              chan  clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    	tcr2_window_start = ertb;
21F4: 0xBFF37B84   alu    p = ertB+0x0;
    :              ram   *((channel int24 *) 0x11) = p_23_0;;
    	tcr2_window_end = ertb + erta;
21F8: 0x000E1419   alu    sr = ertA+0x0;;
21FC: 0xBF537B85   alu    p = ertB+sr;
    :              ram   *((channel int24 *) 0x15) = p_23_0;;
        /* Schedule start angle */
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    	
    	/* Increment p_window pointer */
    	p_window++;
2200: 0xBFEFFB81   ram   p_23_0 = *((channel int24 *) 0x5);;
2204: 0x00287419   alu    p = p+0x8;;
2208: 0xBFFFFB81   ram   *((channel int24 *) 0x5) = p_23_0;;
    	/* Increment window counter */
    	window_counter++;
220C: 0xCFEFF981   ram   p_31_24 = *((channel int8 *) 0x4);;
2210: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
2214: 0xCFFFF981   ram   *((channel int8 *) 0x4) = p_31_24;;
    	/* Last window in cycle? */
    	if(window_counter >= window_count)
2218: 0x00020419   alu    a = p_31_24+0x0;;
221C: 0xCFEFF980   ram   p_31_24 = *((channel int8 *) 0x0);;
2220: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
2224: 0xF4D11207   seq  if LowerOrEqual==false then goto addr_0x2240, flush;;
    	{
    		/* Reset window pointer and counter */
    		window_counter = 0;
2228: 0xCFFFF901   ram   *((channel int8 *) 0x4) =  0;;
    		p_window = p_window_first;
222C: 0xBFEFFB80   ram   p_23_0 = *((channel int24 *) 0x1);;
2230: 0xBFFFFB81   ram   *((channel int24 *) 0x5) = p_23_0;;
    		/* Update actual TDC angle for next cycle */
    		tdc_angle_actual += eng_cycle_tcr2_ticks;
2234: 0x9FEFFB00   ram   p_23_0 = *((global int24 *) 0x1);;
2238: 0xBFE80B83   alu    a = p+0x0;
    :              ram   p_23_0 = *((channel int24 *) 0xD);;
223C: 0xBF387B83   alu    p = p+a;
    :              ram   *((channel int24 *) 0xD) = p_23_0;;
    	}
    }
2240: 0x0FFFFFFF   seq   end;;
    
    
    /*******************************************************************************
    *  eTPU Function
    *******************************************************************************/
    
    /**************************************************************************
    * THREAD NAME: INIT
    * DESCRIPTION: Initialize the channel to run the KNOCK function.
    **************************************************************************/
    _eTPU_thread KNOCK::INIT(_eTPU_matches_disabled)
    {
    	/* Stop the channel */
    	/* Disable event handling */
    	channel.MTD = MTD_DISABLE;
2244: 0xFB77FEFB   chan  clear TransitionDetectionLatches, clear MatchEnableLatches, DisableMatchTransitionServicing;;
    	/* Disable match detection */
    	channel.MRLE = MRLE_DISABLE;
    	/* Reset all latches */
    	channel.TDL = TDL_CLEAR;
    	channel.LSR = LSR_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    
    	/* Initialize the channel */
    	/* Set channel mode: match 2 single transition
    	   - Match B is serviced, Match A is not serviced */
    	channel.PDCM = PDCM_M2_ST;
    	/* Time base selection */
    	channel.TBSA = TBS_M1C1GE;  /* match on time and capture time */
    	channel.TBSB = TBS_M2C1GE;  /* match on angle and capture time */
    	/* Input pin action control */
    	channel.IPACA = IPAC_NO_DETECT;
    	channel.IPACB = IPAC_NO_DETECT;
    	/* Output pin state and Output pin action control */
    	if(channel.FM0 == KNOCK_FM0_ACTIVE_HIGH)
2248: 0xF3F912C7   seq  if FunctionMode0==true then goto addr_0x2258, no_flush;;
224C: 0x581016A9   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr2 >= match, capture tcr1,
    :                    clear LinkServiceRequest, mode = matchB single transition, detectA = off, detectB = off;;
    	{
    		channel.PIN = PIN_SET_LOW;
    		channel.OPACA = OPAC_MATCH_LOW;
    		channel.OPACB = OPAC_MATCH_HIGH;
    	}
2250: 0xF7F112E7   seq  goto addr_0x225C, no_flush;;
2254: 0x4A3FFDFE   chan  CurrentOutputPin = low, FutureOutputPin low on matchA, FutureOutputPin high on matchB;;
    	else
    	{
    		channel.PIN = PIN_SET_HIGH;
2258: 0x495FFBFE   chan  CurrentOutputPin = high, FutureOutputPin high on matchA, FutureOutputPin low on matchB;;
    		channel.OPACA = OPAC_MATCH_HIGH;
    		channel.OPACB = OPAC_MATCH_LOW;
    	}
    	/* Enable output pin buffer */
    	channel.TBSA = TBSA_SET_OBE;
225C: 0x4FF8FFFF   chan  enable output buffer;;
    	/* Channel flags */
    	channel.FLAG0 = KNOCK_FLAG0_WINDOW_NOT_ACTIVE;
2260: 0xDF28FA82   ram   p_23_0 = *((channel int24 *) 0x9);
    :              chan  clear ChannelFlag0, EnableMatchTransitionServicing;;
    	/* Initialize actual TDC angle */
    	tdc_angle_actual = eng_cycle_tcr2_start + tdc_angle;
2264: 0x9FE80B01   alu    a = p+0x0;
    :              ram   p_23_0 = *((global int24 *) 0x5);;
2268: 0xBF387B83   alu    p = p+a;
    :              ram   *((channel int24 *) 0xD) = p_23_0;;
    	/* Initialize window pointer and counter */
    	p_window = p_window_first;
226C: 0xBFEFFB80   ram   p_23_0 = *((channel int24 *) 0x1);;
2270: 0xBFFFFB81   ram   *((channel int24 *) 0x5) = p_23_0;;
    	window_counter = 0;
2274: 0xCFFFF901   ram   *((channel int8 *) 0x4) =  0;;
    	/* Enable event handling */
    	channel.MTD = MTD_ENABLE;
    	
        if (eng_pos_state != ENG_POS_FULL_SYNC)
2278: 0xCFEFF100   ram   p_31_24 = *((global int8 *) 0x0);;
227C: 0x0802FBEA   alu    nil = p_31_24 ^ 0x3, SampleFlags;;
2280: 0xF0D90EC7   seq  if z==true then goto addr_0x21D8, flush;;
        {
            /* only fully start the knock processing once sync is achieved */
            return;
2284: 0x0FFFFFFF   seq   end;;
        }
    	
    	/* Schedule the first start angle */
    	ScheduleStartAngle_NoReturn();
    }
    
    /**************************************************************************
    * THREAD NAME: STOP
    * DESCRIPTION: Stop the running injection sequence.
    *              The next injection sequence will start normally. 
    **************************************************************************/
    _eTPU_thread KNOCK::STOP(_eTPU_matches_disabled)
    {
    	/* Disable event handling */
    	channel.MTD = MTD_DISABLE;
2288: 0xFB77FEFB   chan  clear TransitionDetectionLatches, clear MatchEnableLatches, DisableMatchTransitionServicing;;
    	/* Disable match detection */
    	channel.MRLE = MRLE_DISABLE;
    	/* Reset all latches */
    	channel.TDL = TDL_CLEAR;
    	channel.LSR = LSR_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    	/* Output pin action control */
    	if(channel.FM0 == KNOCK_FM0_ACTIVE_HIGH)
228C: 0xF3F914C7   seq  if FunctionMode0==true then goto addr_0x2298, no_flush;;
2290: 0x4FFFF6BF   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, clear LinkServiceRequest;;
    	{
    		channel.PIN = PIN_SET_LOW;
2294: 0x6FFFFDFE   chan  CurrentOutputPin = low;
    :              seq   end;;
    	}
    	else
    	{
    		channel.PIN = PIN_SET_HIGH;
2298: 0x6FFFFBFE   chan  CurrentOutputPin = high;
    :              seq   end;;
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: WINDOW_START
    * DESCRIPTION: Window start angle.
    **************************************************************************/
    _eTPU_thread KNOCK::WINDOW_START(_eTPU_matches_disabled)
    {
    	/* IRQ & DMA at window start */
    	if(irq_dma_options & KNOCK_IRQ_AT_WINDOW_START)
229C: 0xF5111527   seq  if p.bit(24)==false then goto addr_0x22A4, flush;;
    	{
    		channel.CIRC = CIRC_INT_FROM_SERVICED;
22A0: 0xFFFF3EF9   chan  set SvcdChan ChannelIntr;;
    	}
    	if(irq_dma_options & KNOCK_DMA_AT_WINDOW_START)
22A4: 0xF6111567   seq  if p.bit(28)==false then goto addr_0x22AC, flush;;
    	{
    		channel.CIRC = CIRC_DATA_FROM_SERVICED;
22A8: 0xFFFF7EF9   chan  set SvcdChan DataTransferIntr;;
    	}
    
    	/* Channel flag */
    	channel.FLAG0 = KNOCK_FLAG0_WINDOW_ACTIVE;
    	
    	if(cc.FM1 == KNOCK_FM1_MODE_GATE)
22AC: 0xF3B91667   seq  if FunctionMode1==true then goto addr_0x22CC, no_flush;;
22B0: 0x0FFFFEFE   chan  set ChannelFlag0;;
    	{
    		/* Channel flag */
    		channel.FLAG1 = KNOCK_FLAG1_MODE_GATE;
22B4: 0x0FFFFF7E   chan  clear ChannelFlag1;;
    		/* Output pin action control */
    		channel.OPACB = OPAC_MATCH_LOW;
    		if(channel.FM0 == KNOCK_FM0_ACTIVE_LOW)
22B8: 0xF3F11627   seq  if FunctionMode0==false then goto addr_0x22C4, no_flush;;
22BC: 0x4F5FFFFF   chan  FutureOutputPin low on matchB;;
    		{
    			channel.OPACB = OPAC_MATCH_HIGH;
22C0: 0x4F3FFFFF   chan  FutureOutputPin high on matchB;;
    		}
    		/* Schedule WINDOW_END */
    		ertb = tcr2_window_end;
22C4: 0xBFEFFB85   ram   p_23_0 = *((channel int24 *) 0x15);;
    		channel.MRLB = MRL_CLEAR;
    		channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
22C8: 0x6FF83F9F   alu    ertB = p+0x0;
    :              chan  clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;
    :              seq   end;;
    	}
    	else  /* KNOCK_FM1_MODE_TRIGGER */
    	{
    		/* Channel flag */
    		channel.FLAG1 = KNOCK_FLAG1_MODE_TRIGGER;
22CC: 0xCFEBFA86   ram   p_23_0 = *((channel int24 *) 0x19);
    :              chan  set ChannelFlag1;;
    		/* Time base selection */
    		channel.TBSB = TBS_M1C1GE;  /* match on time and capture time */
22D0: 0x4FFF0FFF   chan  ActionUnitB: tcr1 >= match, capture tcr1;;
    		/* Schedule end of trigger pulse */
    		erta = ertb + (trigger_period >> 1);
22D4: 0x1C080792   alu    a = (p+0x0) >> 1;;
22D8: 0x7F332E3F   alu    ertA = ertB+a;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, clear MatchRecognitionLatchB;;
    		channel.MRLB = MRL_CLEAR;
    		channel.MRLA = MRL_CLEAR;
    		channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    		/* Schedule next TRIGGER */
    		ertb += trigger_period;
    		channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
22DC: 0x6F133FDF   alu    ertB = ertB+p;
    :              chan  matchB = ertB, set MatchEnableLatchB;
    :              seq   end;;
    	}
    }
    
    /**************************************************************************
    * THREAD NAME: WINDOW_END
    * DESCRIPTION: Gate Window end angle.
    **************************************************************************/
    _eTPU_thread KNOCK::WINDOW_END(_eTPU_matches_disabled)
    {
    	/* IRQ & DMA at window end */
    	if(irq_dma_options & KNOCK_IRQ_AT_WINDOW_END)
22E0: 0xF5511747   seq  if p.bit(25)==false then goto addr_0x22E8, flush;;
    	{
    		channel.CIRC = CIRC_INT_FROM_SERVICED;
22E4: 0xFFFF3EF9   chan  set SvcdChan ChannelIntr;;
    	}
    	if(irq_dma_options & KNOCK_DMA_AT_WINDOW_END)
22E8: 0xF6511787   seq  if p.bit(29)==false then goto addr_0x22F0, flush;;
    	{
    		channel.CIRC = CIRC_DATA_FROM_SERVICED;
22EC: 0xFFFF7EF9   chan  set SvcdChan DataTransferIntr;;
    	}
    
    	/* Channel flag */
    	channel.FLAG0 = KNOCK_FLAG0_WINDOW_NOT_ACTIVE;
22F0: 0x0FFFFE7E   chan  clear ChannelFlag0;;
    	/* Output pin action control */
    	channel.OPACB = OPAC_MATCH_HIGH;
    	if(channel.FM0 == KNOCK_FM0_ACTIVE_LOW)
22F4: 0xF3F10EC7   seq  if FunctionMode0==false then goto addr_0x21D8, no_flush;;
22F8: 0x4F3FFFFF   chan  FutureOutputPin high on matchB;;
    	{
    		channel.OPACB = OPAC_MATCH_LOW;
    	}
    	/* Schedule next window start */
    	ScheduleStartAngle_NoReturn();
22FC: 0xF7F10EC7   seq  goto addr_0x21D8, no_flush;;
2300: 0x4F5FFFFF   chan  FutureOutputPin low on matchB;;
    }
    
    /**************************************************************************
    * THREAD NAME: TRIGGER
    * DESCRIPTION: Trigger pulse active edge.
    **************************************************************************/
    _eTPU_thread KNOCK::TRIGGER(_eTPU_matches_disabled)
    {
    	/* IRQ & DMA at every trigger */
    	if(irq_dma_options & KNOCK_IRQ_AT_EVERY_TRIGGER)
2304: 0xF5911867   seq  if p.bit(26)==false then goto addr_0x230C, flush;;
    	{
    		channel.CIRC = CIRC_INT_FROM_SERVICED;
2308: 0xFFFF3EF9   chan  set SvcdChan ChannelIntr;;
    	}
    	if(irq_dma_options & KNOCK_DMA_AT_EVERY_TRIGGER)
230C: 0xF69118A7   seq  if p.bit(30)==false then goto addr_0x2314, flush;;
    	{
    		channel.CIRC = CIRC_DATA_FROM_SERVICED;
2310: 0xFFFF7EF9   chan  set SvcdChan DataTransferIntr;;
    	}
    	
    	/* Schedule end of this trigger pulse */
    	erta = ertb + (trigger_period >> 1);
2314: 0xBFEFFB86   ram   p_23_0 = *((channel int24 *) 0x19);;
2318: 0xB7E80B85   alu    a = (p+0x0) >> 1;
    :              ram   p_23_0 = *((channel int24 *) 0x15);;
231C: 0x7F332E3F   alu    ertA = ertB+a;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, clear MatchRecognitionLatchB;;
    	channel.MRLB = MRL_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    
    	/* End of window? */
    	if(tcr2 >= tcr2_window_end)
2320: 0x1C1DFEFF   alu    nil = tcr2-p, SampleFlags;;
2324: 0xF4991A27   seq  if LessThan==true then goto addr_0x2344, flush;;
    	{
    		/* IRQ & DMA at window end */
    		if(irq_dma_options & KNOCK_IRQ_AT_WINDOW_END)
2328: 0xF5511987   seq  if p.bit(25)==false then goto addr_0x2330, flush;;
    		{
    			channel.CIRC = CIRC_INT_FROM_SERVICED;
232C: 0xFFFF3EF9   chan  set SvcdChan ChannelIntr;;
    		}
    		if(irq_dma_options & KNOCK_DMA_AT_WINDOW_END)
2330: 0xF65119C7   seq  if p.bit(29)==false then goto addr_0x2338, flush;;
    		{
    			channel.CIRC = CIRC_DATA_FROM_SERVICED;
2334: 0xFFFF7EF9   chan  set SvcdChan DataTransferIntr;;
    		}
    
    		/* Channel flag */
    		channel.FLAG0 = KNOCK_FLAG0_WINDOW_NOT_ACTIVE;
2338: 0x0FFFFE7E   chan  clear ChannelFlag0;;
    		/* Time base selection */
    		channel.TBSB = TBS_M2C1GE;  /* match on angle and capture time */
    		/* Schedule next WINDOW_START */
    		ScheduleStartAngle_NoReturn();
233C: 0xF7F10EC7   seq  goto addr_0x21D8, no_flush;;
2340: 0x4FFF1FFF   chan  ActionUnitB: tcr2 >= match, capture tcr1;;
    	}
    	else
    	{
    		/* Schedule next TRIGGER */
    		ertb += trigger_period;
2344: 0xBFEFFB86   ram   p_23_0 = *((channel int24 *) 0x19);;
    		channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
2348: 0x6F133FDF   alu    ertB = ertB+p;
    :              chan  matchB = ertB, set MatchEnableLatchB;
    :              seq   end;;
    	}
    }
    
    
    DEFINE_ENTRY_TABLE(KNOCK, KNOCK, alternate, outputpin, autocfsr)
    {
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(6,7,   x,  x, x, x,  x, x, INIT),
014A: 0x0891       Alt Entry 5, Addr 0x2244, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==6,7    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 0,  x, x, INIT),
014C: 0x0891       Alt Entry 6, Addr 0x2244, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==0  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 1,  x, x, INIT),
014E: 0x0891       Alt Entry 7, Addr 0x2244, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==1  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR3(1,4,5, x,  x, x, x,  x, x, STOP),
0148: 0x08A2       Alt Entry 4, Addr 0x2288, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==1,4,5  Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 0, WINDOW_START),
0160: 0x88A7       Alt Entry 16, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 1, WINDOW_START),
0164: 0x88A7       Alt Entry 18, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 0, WINDOW_START),
0168: 0x88A7       Alt Entry 20, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 1, WINDOW_START),
016C: 0x88A7       Alt Entry 22, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 0, WINDOW_START),
0170: 0x88A7       Alt Entry 24, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 1, WINDOW_START),
0174: 0x88A7       Alt Entry 26, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 0, WINDOW_START),
0178: 0x88A7       Alt Entry 28, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 1, WINDOW_START),
017C: 0x88A7       Alt Entry 30, Addr 0x229C, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 0, WINDOW_END),
0162: 0x88B8       Alt Entry 17, Addr 0x22E0, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 0, WINDOW_END),
016A: 0x88B8       Alt Entry 21, Addr 0x22E0, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 0, WINDOW_END),
0172: 0x88B8       Alt Entry 25, Addr 0x22E0, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 0, WINDOW_END),
017A: 0x88B8       Alt Entry 29, Addr 0x22E0, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 1, TRIGGER),
0166: 0x88C1       Alt Entry 19, Addr 0x2304, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 1, TRIGGER),
016E: 0x88C1       Alt Entry 23, Addr 0x2304, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 1, TRIGGER),
0176: 0x88C1       Alt Entry 27, Addr 0x2304, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 1, TRIGGER),
017E: 0x88C1       Alt Entry 31, Addr 0x2304, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
        // unused/invalid entries
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  0, x, _Error_handler_unexpected_thread),
0140: 0x09F4       Alt Entry 0, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  1, x, _Error_handler_unexpected_thread),
0142: 0x09F4       Alt Entry 1, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  0, x, _Error_handler_unexpected_thread),
0144: 0x09F4       Alt Entry 2, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  1, x, _Error_handler_unexpected_thread),
0146: 0x09F4       Alt Entry 3, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 0, _Error_handler_unexpected_thread),
0150: 0x09F4       Alt Entry 8, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 0, _Error_handler_unexpected_thread),
0152: 0x09F4       Alt Entry 9, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 1, _Error_handler_unexpected_thread),
0154: 0x09F4       Alt Entry 10, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 1, _Error_handler_unexpected_thread),
0156: 0x09F4       Alt Entry 11, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 0, _Error_handler_unexpected_thread),
0158: 0x09F4       Alt Entry 12, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 0, _Error_handler_unexpected_thread),
015A: 0x09F4       Alt Entry 13, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 1, _Error_handler_unexpected_thread),
015C: 0x09F4       Alt Entry 14, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 1, _Error_handler_unexpected_thread),
015E: 0x09F4       Alt Entry 15, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==1
    };
    
    
    /*******************************************************************************
    *  Export interface information to Host CPU program. 
    *******************************************************************************/
    /* [MISRA 2004 Rule 3.4] usage of #pragma write documented in the Pragma Write 
       Manual, see https://www.ashware.com/Manuals */
    #pragma write h, (::ETPUfilename (cpu/etpu_knock_auto.h));
    #pragma write h, (/**************************************************************** );
    #pragma write h, (* WARNING: This file is automatically generated. DO NOT EDIT IT! );
    #pragma write h, (*);
    #pragma write h, (* COPYRIGHT (c) Freescale 2004-2014, All Rights Reserved );
    #pragma write h, (*);
    #pragma write h, (* FILE NAME: etpu_knock_auto.h  );
    #if defined(__TARGET_ETPU1__) || defined(__ETPU__)
    #pragma write h, (* ARCHITECTURE: eTPU );
    #else
    #pragma write h, (* ARCHITECTURE: eTPU2 );
    #endif
    #pragma write h, (*);
    #pragma write h, (* This file was generated by: __FILE__ on __DATE__, __TIME__ );
    #pragma write h, (*);
    #pragma write h, (* This file provides an interface between eTPU code and CPU       );
    #pragma write h, (* code. All references to the eTPU function should be made with   );
    #pragma write h, (* information in this file. This allows only symbolic             );
    #pragma write h, (* information to be referenced which allows the eTPU code to be   );
    #pragma write h, (* optimized without effecting the CPU code.                       );
    #pragma write h, (*****************************************************************/);
    #pragma write h, (#ifndef _ETPU_KNOCK_AUTO_H_ );
    #pragma write h, (#define _ETPU_KNOCK_AUTO_H_ );
    #pragma write h, ( );
    #pragma write h, (/* Function Configuration Information */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_FUNCTION_NUMBER) ::ETPUfunctionnumber(KNOCK) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_TABLE_SELECT) ::ETPUentrytype(KNOCK) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_NUM_PARMS) ::ETPUram(KNOCK) );
    #pragma write h, ( );
    #pragma write h, (/* Host Service Request Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_HSR_INIT)         KNOCK_HSR_INIT );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_HSR_STOP)         KNOCK_HSR_STOP );
    #pragma write h, ( );
    #pragma write h, (/* Function Mode Bit Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_FM0_ACTIVE_HIGH)  KNOCK_FM0_ACTIVE_HIGH );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_FM0_ACTIVE_LOW)   KNOCK_FM0_ACTIVE_LOW );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_FM1_MODE_GATE)    (KNOCK_FM1_MODE_GATE<<1) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_FM1_MODE_TRIGGER) (KNOCK_FM1_MODE_TRIGGER<<1) );
    #pragma write h, ( );
    #pragma write h, (/* Parameter Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_P_WINDOW_FIRST)    ::ETPUlocation (KNOCK, p_window_first) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_P_WINDOW)          ::ETPUlocation (KNOCK, p_window) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_TDC_ANGLE)         ::ETPUlocation (KNOCK, tdc_angle) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_TDC_ANGLE_ACTUAL)  ::ETPUlocation (KNOCK, tdc_angle_actual) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_TCR2_WINDOW_START) ::ETPUlocation (KNOCK, tcr2_window_start) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_TCR2_WINDOW_END)   ::ETPUlocation (KNOCK, tcr2_window_end) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_TRIGGER_PERIOD)    ::ETPUlocation (KNOCK, trigger_period) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_WINDOW_COUNT)      ::ETPUlocation (KNOCK, window_count) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_WINDOW_COUNTER)    ::ETPUlocation (KNOCK, window_counter) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_OFFSET_IRQ_DMA_OPTIONS)   ::ETPUlocation (KNOCK, irq_dma_options) );
    #pragma write h, ( );
    #pragma write h, (/* Window Structure Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_WINDOW_OFFSET_START)   0x01 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_WINDOW_OFFSET_WIDTH)   0x05 );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_WINDOW_STRUCT_SIZE)    0x08 );
    #pragma write h, ( );
    #pragma write h, (/* IRQ & DMA Options */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_IRQ_AT_WINDOW_START)   KNOCK_IRQ_AT_WINDOW_START );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_IRQ_AT_WINDOW_END)     KNOCK_IRQ_AT_WINDOW_END );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_IRQ_AT_EVERY_TRIGGER)  KNOCK_IRQ_AT_EVERY_TRIGGER );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_DMA_AT_WINDOW_START)   KNOCK_DMA_AT_WINDOW_START );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_DMA_AT_WINDOW_END)     KNOCK_DMA_AT_WINDOW_END );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_KNOCK_DMA_AT_EVERY_TRIGGER)  KNOCK_DMA_AT_EVERY_TRIGGER );
    #pragma write h, ( );
    #pragma write h, (#endif );
    
    /*********************************************************************
     *
     * Copyright:
     *	Freescale Semiconductor, INC. All Rights Reserved.
     *  You are hereby granted a copyright license to use, modify, and
     *  distribute the SOFTWARE so long as this entire notice is
     *  retained without alteration in any modified and/or redistributed
     *  versions, and that such modified versions are clearly identified
     *  as such. No licenses are granted by implication, estoppel or
     *  otherwise under any patents or trademarks of Freescale
     *  Semiconductor, Inc. This software is provided on an "AS IS"
     *  basis and without warranty.
     *
     *  To the maximum extent permitted by applicable law, Freescale
     *  Semiconductor DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
     *  INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
     *  PARTICULAR PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH
     *  REGARD TO THE SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
     *  AND ANY ACCOMPANYING WRITTEN MATERIALS.
     *
     *  To the maximum extent permitted by applicable law, IN NO EVENT
     *  SHALL Freescale Semiconductor BE LIABLE FOR ANY DAMAGES WHATSOEVER
     *  (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
     *  BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER
     *  PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
     *
     *  Freescale Semiconductor assumes no responsibility for the
     *  maintenance and support of this software
     ********************************************************************/
    
    /*******************************************************************************
    *
    *  REVISION HISTORY:
    *
    *  FILE OWNER: Milan Brejl [r54529]
    *  Revision 1.0  2014/03/16  r54529
    *  Minor comment and formating improvements. MISRA compliancy check.
    *  Ready for eTPU Engine Control Library release 1.0.
    *
    *  Revision 0.1  2013/09/06  r54529
    *  Initial version.
    *
    *******************************************************************************/
