ETEC Tools V3.00A                  ASH WARE Inc.                  (C) 2015-2020
    /*******************************************************************************
    * This file has been modified by ASH WARE Inc. as allowed per the original 
    * license (see bottom of file), to add features and fix issues.
    *******************************************************************************/
    
    /*******************************************************************************
    *
    *  FREESCALE SEMICONDUCTOR INC. 2013-2014
    *  ALL RIGHTS RESERVED
    *  COPYRIGHT (c)
    *
    ********************************************************************************
    *
    *  FILE NAME:  etpuc_tg.c
    *
    *  DESCRIPTION:
    *    This eTPU function generates a Crank & Cam tooth pattern.
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  Includes
    *******************************************************************************/
    #include <etpu_std.h>
    #include "etpuc_tg.h"
    #include "etpuc_set.h"
    
    /*******************************************************************************
    *  eTPU Function Parameters:
    *
    *   tooth_tcr1_time        - TCR1 time of the first tooth edge
    *   tooth_period_actual    - TCR1 tooth period of the actual tooth
    *   tooth_period_target    - TCR1 tooth period to be reached by 
    *                            an acceleration/deceleration profile
    *   accel_ratio            - an unsigned fractional value determining the 
    *                            acceleration/deceleration. 
    *                            Each tooth, the tooth_period_actual is updated:
    *                              tooth_period_actual += accel_ratio * (tooth_period_target - tooth_period_actual)
    *   *p_cam_tooth_first     - pointer to the first tooth number where the Cam 
    *                            is toggled, in an array
    *   *p_cam_tooth           - pointer to the next tooth number where the Cam 
    *                            will be toggled
    *   teeth_till_gap         - number of physical teeth gap to gap
    *   teeth_in_gap           - number if missing teeth in the gap.
    *                            If there is an additional tooth instead of the gap,
    *                            this parameter must be set to 0.
    *   teeth_per_cycle        - number of teeth (including missing teeth in gap)
    *                            per an engine cycle (720 degrees). It must be
    *                            a multiple of (teeth_till_gap + teeth_in_gap).
    *   tooth_counter_gap      - it counts from 1 to teeth_till_gap + teeth_in_gap
    *   tooth_counter_cycle    - it counts from 1 to teeth_per_cycle
    *   cam_chan               - Cam channel number
    *   generation_disable     - disables the generation of Crank output.
    *
    ********************************************************************************
    *
    *  Channel Flag usage
    *    Flag0 is not used.
    *    Flag1 is not used.
    *
    ********************************************************************************
    *
    *  Channel Function Mode (FM) bits usage
    *    FM0 is used to select the initial output polarity:
    *      - TG_FM0_POLARITY_LOW
    *      - TG_FM0_POLARITY_HIGH
    *    FM1 is used to identify CRANK and CAM channels:
    *      - TG_FM1_CRANK
    *      - TG_FM1_CAM
    *
    ********************************************************************************
    *
    *  Channel Interrupt usage
    *    The channel interrupt on the TG channel is set in each CRANK gap. 
    *
    *******************************************************************************/
    
    /*******************************************************************************
    *  eTPU Function
    *******************************************************************************/
    
    /**************************************************************************
    * THREAD NAME: INIT
    * DESCRIPTION: Initialize the channel to run the TG function.
    **************************************************************************/
    _eTPU_thread TG::INIT(_eTPU_matches_disabled)
    {
    	/* Stop the channel */
    	/* Disable event handling */
    	channel.MTD = MTD_DISABLE;
2618: 0xFB77FEFB   chan  clear TransitionDetectionLatches, clear MatchEnableLatches, DisableMatchTransitionServicing;;
    	/* Disable match detection */
    	channel.MRLE = MRLE_DISABLE;
    	/* Reset all latches */
    	channel.TDL = TDL_CLEAR;
    	channel.LSR = LSR_CLEAR;
    	channel.MRLA = MRL_CLEAR;
    	channel.MRLB = MRL_CLEAR;
    
    	/* Initialize the channel */
    	/* Set channel mode: either match non-blocking single transition */
    	channel.PDCM = PDCM_EM_NB_ST;
    	/* Time base selection */
    	channel.TBSA = TBS_M1C1GE;
    	channel.TBSB = TBS_M1C1GE;
    	/* Input pin action control */
    	channel.IPACA = IPAC_NO_DETECT;
    	channel.IPACB = IPAC_NO_DETECT;
    	/* Output pin action control */
    	if(cc.FM0 == TG_FM0_POLARITY_LOW)
261C: 0xF3F93167   seq  if FunctionMode0==true then goto addr_0x262C, no_flush;;
2620: 0x581006A5   chan  clear MatchRecognitionLatchA, clear MatchRecognitionLatchB, ActionUnitA: tcr1 >= match, capture tcr1, ActionUnitB: tcr1 >= match, capture tcr1,
    :                    clear LinkServiceRequest, mode = either match non blocking single transition, detectA = off, detectB = off;;
    	{
    		channel.PIN = PIN_SET_LOW;
    		channel.OPACA = OPAC_MATCH_HIGH;
    		channel.OPACB = OPAC_MATCH_LOW;
    	}
2624: 0xF7F13187   seq  goto addr_0x2630, no_flush;;
2628: 0x495FFDFE   chan  CurrentOutputPin = low, FutureOutputPin high on matchA, FutureOutputPin low on matchB;;
    	else
    	{
    		channel.PIN = PIN_SET_HIGH;
262C: 0x4A3FFBFE   chan  CurrentOutputPin = high, FutureOutputPin low on matchA, FutureOutputPin high on matchB;;
    		channel.OPACA = OPAC_MATCH_LOW;
    		channel.OPACB = OPAC_MATCH_HIGH;
    	}
    	/* Enable output pin buffer */
    	channel.TBSA = TBSA_SET_OBE;
    
    	if(cc.FM1 == TG_FM1_CRANK)
2630: 0xF3B933A7   seq  if FunctionMode1==true then goto addr_0x2674, no_flush;;
2634: 0x4FF8FFFF   chan  enable output buffer;;
    	{
    		/* Output pin action control */
    		if((tooth_period_target <= 0)
    		|| (generation_disable == TG_GENERATION_DISABLED))
2638: 0xBFEFFB82   ram   p_23_0 = *((channel int24 *) 0x9);;
263C: 0x1C1FFEFF   alu    nil = ((u24) 0)-p, SampleFlags;;
2640: 0xF4913287   seq  if LessThan==false then goto addr_0x2650, flush;;
2644: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
2648: 0x0802FBAA   alu    nil = p_31_24 ^ 0x1, SampleFlags;;
264C: 0xF0D132A7   seq  if z==false then goto addr_0x2654, flush;;
    		{
    			channel.OPACA = OPAC_NO_CHANGE;
2650: 0x481FFFFF   chan  FutureOutputPin no change on matchA, FutureOutputPin no change on matchB;;
    			channel.OPACB = OPAC_NO_CHANGE;
    		}
    		/* reset values */
    		tooth_counter_cycle = 1;
2654: 0x000FA439   alu    p_31_24 = ((u24) 0)+0x1;;
2658: 0xCFFFF984   ram   *((channel int8 *) 0x10) = p_31_24;;
    		tooth_counter_gap = 1;
265C: 0xBDEFAB84   alu    p_31_24 = ((u24) 0)+0x1;
    :              ram   p_23_0 = *((channel int24 *) 0x11);;
2660: 0xCFFFF983   ram   *((channel int8 *) 0xC) = p_31_24;;
    		p_cam_tooth = p_cam_tooth_first;
2664: 0xBFFFFB85   ram   *((channel int24 *) 0x15) = p_23_0;;
    		tooth_tcr1_time = tcr1 + tooth_period_actual;
2668: 0xBF7C7B80   alu    p = tcr1+diob;
    :              ram   *((channel int24 *) 0x1) = p_23_0;;
    
    		/* Schedule Match A - the first tooth */
    		erta = tooth_tcr1_time;
266C: 0x00082419   alu    ertA = p+0x0;;
    		channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
2670: 0xFF3FBEFB   chan  matchA = ertA, set MatchEnableLatchA, EnableMatchTransitionServicing;;
    		
    		/* Enable event handling */
    		channel.MTD = MTD_ENABLE;
    	}
    }
2674: 0x0FFFFFFF   seq   end;;
    
    /**************************************************************************
    * THREAD NAME: FIRST_EDGE
    * DESCRIPTION: Update counters, schedule next FIRST_EDGE, care of gap,
    *              possibly toggle Cam output.
    **************************************************************************/
    _eTPU_thread TG::FIRST_EDGE(_eTPU_matches_disabled)
    {
    	/* Count till gap */
    	tooth_counter_gap++;
2678: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
267C: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
2680: 0xCFFFF983   ram   *((channel int8 *) 0xC) = p_31_24;;
    	if(tooth_counter_gap > (teeth_till_gap + teeth_in_gap))
2684: 0xCFEFF981   ram   p_31_24 = *((channel int8 *) 0x4);;
2688: 0x00020419   alu    a = p_31_24+0x0;;
268C: 0xCFEFF980   ram   p_31_24 = *((channel int8 *) 0x0);;
2690: 0x1F320FFF   alu    a = p_31_24+a;;
2694: 0xCFEFF983   ram   p_31_24 = *((channel int8 *) 0xC);;
2698: 0x00021419   alu    sr = p_31_24+0x0;;
269C: 0x1C59AEFF   alu    p_31_24 = a-sr, SampleFlags;;
26A0: 0xF0913567   seq  if cFlag==false then goto addr_0x26AC, flush;;
    	{
    		/* restart gap */
    		tooth_counter_gap = 1;
26A4: 0x000FA439   alu    p_31_24 = ((u24) 0)+0x1;;
26A8: 0xCFFF3983   ram   *((channel int8 *) 0xC) = p_31_24;
    :              chan  set SvcdChan ChannelIntr;;
    		channel.CIRC = CIRC_INT_FROM_SERVICED;
    	}
    	/* Calculate acceleration/deceleration */
    	if(tooth_period_target > 0)
26AC: 0x1C1FFEFF   alu    nil = ((u24) 0)-p, SampleFlags;;
26B0: 0xF4913787   seq  if LessThan==false then goto addr_0x26F0, flush;;
    	{
    		if (tooth_period_actual > tooth_period_target)
26B4: 0xBFEFFF81   ram   diob = *((channel int24 *) 0x5);;
26B8: 0x1C78FEFF   alu    nil = p-diob, SampleFlags;;
26BC: 0xF49136A7   seq  if LessThan==false then goto addr_0x26D4, flush;;
    		{
    			tooth_period_actual -= muliur(tooth_period_actual - tooth_period_target, accel_ratio) + 1;
26C0: 0xBC0B0F83   alu    a = diob-p;
    :              ram   diob = *((channel int24 *) 0xD);;
26C4: 0x2F79FFE9   alu    mac = a * ((u24) diob);;
26C8: 0xF3593647   seq  if MacBusy==true then goto addr_0x26C8, flush;;
26CC: 0xBDC70F81   alu    a = mach+0x1;
    :              ram   diob = *((channel int24 *) 0x5);;
26D0: 0xBC3B4F81   alu    diob = diob-a;
    :              ram   *((channel int24 *) 0x5) = diob;;
    		}
    		if (tooth_period_actual < tooth_period_target)
26D4: 0x1C1BFEFF   alu    nil = diob-p, SampleFlags;;
26D8: 0xF4913787   seq  if LessThan==false then goto addr_0x26F0, flush;;
    		{
    			tooth_period_actual += muliur(tooth_period_target - tooth_period_actual, accel_ratio) + 1;
26DC: 0xBC680F83   alu    a = p-diob;
    :              ram   diob = *((channel int24 *) 0xD);;
26E0: 0x2F79FFE9   alu    mac = a * ((u24) diob);;
26E4: 0xF3593727   seq  if MacBusy==true then goto addr_0x26E4, flush;;
26E8: 0xBDC70F81   alu    a = mach+0x1;
    :              ram   diob = *((channel int24 *) 0x5);;
26EC: 0xBF3B4F81   alu    diob = diob+a;
    :              ram   *((channel int24 *) 0x5) = diob;;
    		}
    	}
    	/* Tooth or gap? */
    	if((tooth_period_target <= 0)
    	|| (generation_disable == TG_GENERATION_DISABLED))
26F0: 0x1C1FFEFF   alu    nil = ((u24) 0)-p, SampleFlags;;
26F4: 0xF4913827   seq  if LessThan==false then goto addr_0x2704, flush;;
26F8: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
26FC: 0x0802FBAA   alu    nil = p_31_24 ^ 0x1, SampleFlags;;
2700: 0xF0D13867   seq  if z==false then goto addr_0x270C, flush;;
    	{
    		channel.OPACA = OPAC_NO_CHANGE;
    		channel.OPACB = OPAC_NO_CHANGE;
    	}
2704: 0xF7F138E7   seq  goto addr_0x271C, no_flush;;
2708: 0x481FFFFF   chan  FutureOutputPin no change on matchA, FutureOutputPin no change on matchB;;
    	else
    	{
    		if(cc.FM0 == TG_FM0_POLARITY_LOW)
270C: 0xF3D938C7   seq  if FunctionMode0==true then goto addr_0x2718, flush;;
    		{
    			channel.OPACA = OPAC_MATCH_HIGH;
    			channel.OPACB = OPAC_MATCH_LOW;
    		}
2710: 0xF7F138E7   seq  goto addr_0x271C, no_flush;;
2714: 0x495FFFFF   chan  FutureOutputPin high on matchA, FutureOutputPin low on matchB;;
    		else
    		{
    			channel.OPACA = OPAC_MATCH_LOW;
2718: 0x4A3FFFFF   chan  FutureOutputPin low on matchA, FutureOutputPin high on matchB;;
    			channel.OPACB = OPAC_MATCH_HIGH;
    		}
    	}
    	
    	/* Schedule the tooth */
    	erta = tooth_tcr1_time + tooth_period_actual;
271C: 0xBFEFFF81   ram   diob = *((channel int24 *) 0x5);;
2720: 0xB7EB0B80   alu    a = (diob+0x0) >> 1;
    :              ram   p_23_0 = *((channel int24 *) 0x1);;
2724: 0xBF682F85   alu    ertA = p+diob;
    :              ram   diob = *((channel int24 *) 0x15);;
    	tooth_tcr1_time = erta;
2728: 0xBFFE7B80   alu    p = ertA+0x0;
    :              ram   *((channel int24 *) 0x1) = p_23_0;;
    	ertb = erta - (tooth_period_actual >> 1);
272C: 0x7C3E3E1F   alu    ertB = ertA-a;
    :              chan  clear MatchRecognitionLatchA, matchA = ertA, set MatchEnableLatchA, clear MatchRecognitionLatchB, matchB = ertB, set MatchEnableLatchB;;
    	channel.MRLA = MRL_CLEAR;
    	channel.ERWA = ERW_WRITE_ERT_TO_MATCH;
    	channel.MRLB = MRL_CLEAR;
    	channel.ERWB = ERW_WRITE_ERT_TO_MATCH;
    	
    	/* Toggle CAM output */
    	if(tooth_counter_cycle == *p_cam_tooth)
2730: 0xFFEFF8D9   ram   p_31_0 = *((int32 *) diob);;
2734: 0x0C0B0BFA   alu    a = diob & 0x3;;
2738: 0x1809F792   alu    nil = (a+0x0) >> 1, SampleFlags;;
273C: 0x1C065602   alu    if  z then p_15_0 = p_31_16+0x0;;
2740: 0x1C01D582   alu    if !cFlag then p_7_0 = p_15_8+0x0;;
2744: 0x00000419   alu    a = p_7_0+0x0;;
2748: 0xCFEFF984   ram   p_31_24 = *((channel int8 *) 0x10);;
274C: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
2750: 0xF0D13B27   seq  if z==false then goto addr_0x2764, flush;;
    	{
    		p_cam_tooth++;
2754: 0xBDFB7B85   alu    p = diob+0x1;
    :              ram   *((channel int24 *) 0x15) = p_23_0;;
    		chan = cam_chan;
2758: 0xCFEFF985   ram   p_31_24 = *((channel int8 *) 0x14);;
275C: 0x00024411   alu    chan = p_31_24+0x0;;
    		channel.OPACA = OPAC_MATCH_TOGGLE;
2760: 0x4BFFF9FE   chan  CurrentOutputPin = opacA, FutureOutputPin toggle on matchA;;
    		channel.PIN = PIN_AS_OPACA;
    	}
    	/* Count cycle */
    	tooth_counter_cycle++;
2764: 0xCFEFF984   ram   p_31_24 = *((channel int8 *) 0x10);;
2768: 0x0002A439   alu    p_31_24 = p_31_24+0x1;;
276C: 0xCFFFF984   ram   *((channel int8 *) 0x10) = p_31_24;;
    	if(tooth_counter_cycle > teeth_per_cycle)
2770: 0x00020419   alu    a = p_31_24+0x0;;
2774: 0xCFEFF982   ram   p_31_24 = *((channel int8 *) 0x8);;
2778: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
277C: 0xF0913C87   seq  if cFlag==false then goto addr_0x2790, flush;;
    	{
    		/* restart cycle */
    		tooth_counter_cycle = 1;
2780: 0x000FA439   alu    p_31_24 = ((u24) 0)+0x1;;
2784: 0xCFFFF984   ram   *((channel int8 *) 0x10) = p_31_24;;
    		p_cam_tooth = p_cam_tooth_first;
2788: 0xBFEFFB84   ram   p_23_0 = *((channel int24 *) 0x11);;
278C: 0xBFFFFB85   ram   *((channel int24 *) 0x15) = p_23_0;;
    	}
    }
2790: 0x0FFFFFFF   seq   end;;
    
    /**************************************************************************
    * THREAD NAME: SECOND_EDGE
    * DESCRIPTION: Schedule next SECOND_EDGE.
    **************************************************************************/
    _eTPU_thread TG::SECOND_EDGE(_eTPU_matches_disabled)
    {
    	channel.MRLB = MRL_CLEAR;
2794: 0xDFEFD983   ram   p_31_24 = *((channel int8 *) 0xC);
    :              chan  clear MatchRecognitionLatchB;;
    	
    	/* Tooth or gap? */
    	if((tooth_counter_gap > teeth_till_gap)
    	|| (tooth_period_target <= 0)
    	|| (generation_disable == TG_GENERATION_DISABLED))
2798: 0x00020419   alu    a = p_31_24+0x0;;
279C: 0xCFEFF980   ram   p_31_24 = *((channel int8 *) 0x0);;
27A0: 0x1C32AEFF   alu    p_31_24 = p_31_24-a, SampleFlags;;
27A4: 0xF0993E07   seq  if cFlag==true then goto addr_0x27C0, flush;;
27A8: 0xBFEFFB82   ram   p_23_0 = *((channel int24 *) 0x9);;
27AC: 0x1C1FFEFF   alu    nil = ((u24) 0)-p, SampleFlags;;
27B0: 0xF4913E07   seq  if LessThan==false then goto addr_0x27C0, flush;;
27B4: 0xCFEFF986   ram   p_31_24 = *((channel int8 *) 0x18);;
27B8: 0x0802FBAA   alu    nil = p_31_24 ^ 0x1, SampleFlags;;
27BC: 0xF0D13E27   seq  if z==false then goto addr_0x27C4, flush;;
    	{
    		channel.OPACA = OPAC_NO_CHANGE;
    		channel.OPACB = OPAC_NO_CHANGE;
27C0: 0x401FFFFF   chan  FutureOutputPin no change on matchA, FutureOutputPin no change on matchB;
    :              seq   end;;
    	}
    	else
    	{
    		if(cc.FM0 == TG_FM0_POLARITY_LOW)
27C4: 0xF3D93E67   seq  if FunctionMode0==true then goto addr_0x27CC, flush;;
    		{
    			channel.OPACA = OPAC_MATCH_HIGH;
    			channel.OPACB = OPAC_MATCH_LOW;
27C8: 0x415FFFFF   chan  FutureOutputPin high on matchA, FutureOutputPin low on matchB;
    :              seq   end;;
    		}
    		else
    		{
    			channel.OPACA = OPAC_MATCH_LOW;
    			channel.OPACB = OPAC_MATCH_HIGH;
27CC: 0x423FFFFF   chan  FutureOutputPin low on matchA, FutureOutputPin high on matchB;
    :              seq   end;;
    		}
    	}
    }
    
    
    DEFINE_ENTRY_TABLE(TG, TG, alternate, outputpin, autocfsr)
    {
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR2(6,7,   x,  x, x, x,  x, x, INIT),
01CA: 0x0986       Alt Entry 5, Addr 0x2618, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==6,7    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 0, FIRST_EDGE),
01D0: 0x899E       Alt Entry 8, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 0, FIRST_EDGE),
01D2: 0x899E       Alt Entry 9, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  0, 1, FIRST_EDGE),
01D4: 0x899E       Alt Entry 10, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 0,  1, 1, FIRST_EDGE),
01D6: 0x899E       Alt Entry 11, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 0, FIRST_EDGE),
01D8: 0x899E       Alt Entry 12, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 0, FIRST_EDGE),
01DA: 0x899E       Alt Entry 13, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  0, 1, FIRST_EDGE),
01DC: 0x899E       Alt Entry 14, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 0, 1,  1, 1, FIRST_EDGE),
01DE: 0x899E       Alt Entry 15, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==0  InputPin==1  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 0, FIRST_EDGE),
01F0: 0x899E       Alt Entry 24, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 0, FIRST_EDGE),
01F2: 0x899E       Alt Entry 25, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  0, 1, FIRST_EDGE),
01F4: 0x899E       Alt Entry 26, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 0,  1, 1, FIRST_EDGE),
01F6: 0x899E       Alt Entry 27, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 0, FIRST_EDGE),
01F8: 0x899E       Alt Entry 28, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 0, FIRST_EDGE),
01FA: 0x899E       Alt Entry 29, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  0, 1, FIRST_EDGE),
01FC: 0x899E       Alt Entry 30, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  1, 1, 1,  1, 1, FIRST_EDGE),
01FE: 0x899E       Alt Entry 31, Addr 0x2678, DisableMatches, p_31_0=*( (channel U32 *)  0x8), diob=*( (channel U24 *)  0xD)
    :              HSR==0b000  Link==X  matchA/TranB==1  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
    	//           HSR    LSR M1 M2 PIN F0 F1 vector
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 0, SECOND_EDGE),
01E0: 0x09E5       Alt Entry 16, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 0, SECOND_EDGE),
01E2: 0x09E5       Alt Entry 17, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  0, 1, SECOND_EDGE),
01E4: 0x09E5       Alt Entry 18, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 0,  1, 1, SECOND_EDGE),
01E6: 0x09E5       Alt Entry 19, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==0  ChanFlag1==1  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 0, SECOND_EDGE),
01E8: 0x09E5       Alt Entry 20, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 0, SECOND_EDGE),
01EA: 0x09E5       Alt Entry 21, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==0  ChanFlag0==1
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  0, 1, SECOND_EDGE),
01EC: 0x09E5       Alt Entry 22, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==0
    	ETPU_VECTOR1(0,     x,  0, 1, 1,  1, 1, SECOND_EDGE),
01EE: 0x09E5       Alt Entry 23, Addr 0x2794, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==X  matchA/TranB==0  matchB/TranA==1  InputPin==1  ChanFlag1==1  ChanFlag0==1
    
        // unused/invalid entries
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  0, x, _Error_handler_unexpected_thread),
01C0: 0x09F4       Alt Entry 0, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 0,  1, x, _Error_handler_unexpected_thread),
01C2: 0x09F4       Alt Entry 1, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==0  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  0, x, _Error_handler_unexpected_thread),
01C4: 0x09F4       Alt Entry 2, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==0
    	ETPU_VECTOR2(2,3,   x,  x, x, 1,  1, x, _Error_handler_unexpected_thread),
01C6: 0x09F4       Alt Entry 3, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==2,3    Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==1  ChanFlag1==X  ChanFlag0==1
    	ETPU_VECTOR3(1,4,5, x,  x, x, x,  x, x, _Error_handler_unexpected_thread),
01C8: 0x09F4       Alt Entry 4, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==1,4,5  Link==X  matchA/TranB==X  matchB/TranA==X  InputPin==X  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 0,  x, x, _Error_handler_unexpected_thread),
01CC: 0x09F4       Alt Entry 6, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==0  ChanFlag1==X  ChanFlag0==X
    	ETPU_VECTOR1(0,     1,  0, 0, 1,  x, x, _Error_handler_unexpected_thread),
01CE: 0x09F4       Alt Entry 7, Addr 0x27D0, DisableMatches, p_31_0=*( (channel U32 *)  0x0), diob=*( (channel U24 *)  0x5)
    :              HSR==0b000  Link==1  matchA/TranB==0  matchB/TranA==0  InputPin==1  ChanFlag1==X  ChanFlag0==X
    };
    
    
    /*******************************************************************************
    *  Export interface information to Host CPU program.
    *******************************************************************************/
    /* [MISRA 2004 Rule 3.4] usage of #pragma write documented in the Pragma Write 
       Manual, see https://www.ashware.com/Manuals */
    #pragma write h, (::ETPUfilename (cpu/etpu_tg_auto.h));
    #pragma write h, (/**************************************************************** );
    #pragma write h, (* WARNING: This file is automatically generated. DO NOT EDIT IT! );
    #pragma write h, (*);
    #pragma write h, (* FILE NAME: etpu_tg_auto.h  );
    #if defined(__TARGET_ETPU1__)
    #pragma write h, (* ARCHITECTURE: eTPU );
    #else
    #pragma write h, (* ARCHITECTURE: eTPU2 );
    #endif
    #pragma write h, (*);
    #pragma write h, (* This file was generated by: __FILE__ on __DATE__, __TIME__ );
    #pragma write h, (*);
    #pragma write h, (* This file provides an interface between eTPU code and CPU       );
    #pragma write h, (* code. All references to the eTPU function should be made with   );
    #pragma write h, (* information in this file. This allows only symbolic             );
    #pragma write h, (* information to be referenced which allows the eTPU code to be   );
    #pragma write h, (* optimized without effecting the CPU code.                       );
    #pragma write h, (*****************************************************************/);
    #pragma write h, (#ifndef _ETPU_TG_AUTO_H_ );
    #pragma write h, (#define _ETPU_TG_AUTO_H_ );
    #pragma write h, ( );
    #pragma write h, (/* Function Configuration Information */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_FUNCTION_NUMBER) ::ETPUfunctionnumber(TG) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_TABLE_SELECT) ::ETPUentrytype(TG) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_NUM_PARMS) ::ETPUram(TG) );
    #pragma write h, ( );
    #pragma write h, (/* Host Service Request Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_HSR_INIT)         TG_HSR_INIT );
    #pragma write h, ( );
    #pragma write h, (/* Function Mode Bit Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_FM0_POLARITY_LOW)  TG_FM0_POLARITY_LOW );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_FM0_POLARITY_HIGH) TG_FM0_POLARITY_HIGH );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_FM1_CRANK)         (TG_FM1_CRANK << 1) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_FM1_CAM)           (TG_FM1_CAM << 1) );
    #pragma write h, ( );
    #pragma write h, (/* Parameter Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TOOTH_TCR1_TIME    ) ::ETPUlocation (TG, tooth_tcr1_time    ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TOOTH_PERIOD_ACTUAL) ::ETPUlocation (TG, tooth_period_actual) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TOOTH_PERIOD_TARGET) ::ETPUlocation (TG, tooth_period_target) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_ACCEL_RATIO        ) ::ETPUlocation (TG, accel_ratio        ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_P_CAM_TOOTH_FIRST  ) ::ETPUlocation (TG, p_cam_tooth_first  ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_P_CAM_TOOTH        ) ::ETPUlocation (TG, p_cam_tooth        ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TEETH_TILL_GAP     ) ::ETPUlocation (TG, teeth_till_gap     ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TEETH_IN_GAP       ) ::ETPUlocation (TG, teeth_in_gap       ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TEETH_PER_CYCLE    ) ::ETPUlocation (TG, teeth_per_cycle    ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TOOTH_COUNTER_GAP  ) ::ETPUlocation (TG, tooth_counter_gap  ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_TOOTH_COUNTER_CYCLE) ::ETPUlocation (TG, tooth_counter_cycle) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_CAM_CHAN           ) ::ETPUlocation (TG, cam_chan           ) );
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_OFFSET_GENERATION_DISABLE ) ::ETPUlocation (TG, generation_disable ) );
    #pragma write h, ( );
    #pragma write h, (/* Generation Disable Definitions */);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_GENERATION_ALLOWED)         TG_GENERATION_ALLOWED);
    #pragma write h, (::ETPUliteral(#define FS_ETPU_TG_GENERATION_DISABLED)        TG_GENERATION_DISABLED);
    #pragma write h, ( );
    #pragma write h, (#endif );
    
    /*********************************************************************
     *
     * Copyright:
     *	Freescale Semiconductor, INC. All Rights Reserved.
     *  You are hereby granted a copyright license to use, modify, and
     *  distribute the SOFTWARE so long as this entire notice is
     *  retained without alteration in any modified and/or redistributed
     *  versions, and that such modified versions are clearly identified
     *  as such. No licenses are granted by implication, estoppel or
     *  otherwise under any patents or trademarks of Freescale
     *  Semiconductor, Inc. This software is provided on an "AS IS"
     *  basis and without warranty.
     *
     *  To the maximum extent permitted by applicable law, Freescale
     *  Semiconductor DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
     *  INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
     *  PARTICULAR PURPOSE AND ANY WARRANTY AGAINST INFRINGEMENT WITH
     *  REGARD TO THE SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
     *  AND ANY ACCOMPANYING WRITTEN MATERIALS.
     *
     *  To the maximum extent permitted by applicable law, IN NO EVENT
     *  SHALL Freescale Semiconductor BE LIABLE FOR ANY DAMAGES WHATSOEVER
     *  (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
     *  BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER
     *  PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
     *
     *  Freescale Semiconductor assumes no responsibility for the
     *  maintenance and support of this software
     ********************************************************************/
    
    /*******************************************************************************
    *
    *  REVISION HISTORY:
    *
    *  FILE OWNER: Milan Brejl [r54529]
    *  Revision 1.0  2014/03/16  r54529
    *  Minor comment and formating improvements. MISRA compliancy check.
    *  Ready for eTPU Engine Control Library release 1.0.
    *
    *  Revision 0.4  2013/10/29  r54529
    *  generation_disable switch added.
    *
    *  Revision 0.3  2013/07/25  r54529
    *  FM1 (polarity) option separated for Crank and Cam.
    *
    *  Revision 0.2  2013/06/19  r54529
    *  Acceleration and deceleration added.
    *
    *  Revision 0.1  2012/11/27  r54529
    *  Initial version.
    *
    *******************************************************************************/
