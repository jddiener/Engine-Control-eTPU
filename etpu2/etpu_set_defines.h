// This file is auto-generated by the ASH WARE ETEC Linker.
// It contains useful information for host-CPU side driver code
//    !!!   DO NOT EDIT THIS FILE   !!!
// Copyright (C) 2015 ASH WARE, Inc.

#ifndef __etpu_set_defines_H
#define __etpu_set_defines_H

// Register ECR, field ETB, byte address, Each Engine
// ECR.ETB = (_ENTRY_TABLE_BASE_ADDR_)>>11;
#define _ENTRY_TABLE_BASE_ADDR_                  0x00

// Starting DATA RAM address where the block copy of initialized data begins
// memcpy( ETPU_DATA_RAM_START+_GLOBAL_INIT_DATA_ADDR_, &_global_mem_init[0], _GLOBAL_DATA_SIZE_);
#define _GLOBAL_INIT_DATA_ADDR_                  0x00

// Register MISCCMPR - ETPU MISC Compare Register
// MISCCMPR = _MISC_VALUE_;
#define _MISC_VALUE_                             0x70599B72

// SCM Off Opcode - opcode returned when in the weeds
// SCMOFFDATAR = _SCM_OFF_OPCODE_;
#define _SCM_OFF_OPCODE_                         0xFFD13F47

// exported autodef macros from user "#pragma export_autodef_macro" commands
// none specified

// exported autodef text from user "#pragma export_autodef_text" commands
// none specified

// 8-bit Global Variable address
// address = SPRAM + _GLOB_VAR8_eng_pos_state_
#define _GLOB_VAR8_eng_pos_state_                0x00

// 24-bit Global Variable address
// address = SPRAM + _GLOB_VAR24_eng_cycle_tcr2_ticks_
#define _GLOB_VAR24_eng_cycle_tcr2_ticks_        0x01
#define _GLOB_VAR24_eng_cycle_tcr2_start_        0x05
#define _GLOB_VAR24_eng_trr_norm_                0x09
#define _GLOB_VAR24_tooth_period_                0x0D

// 32-bit Global Variable address
// address = SPRAM + _GLOB_VAR32__Global_error_data_
#define _GLOB_VAR32__Global_error_data_          0x14

// tag type info used by global variables

// defines for type struct INJ_GLOBAL_PARAMS
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _GLOB_TAG_TYPE_SIZE_INJ_GLOBAL_PARAMS_
#define _GLOB_TAG_TYPE_SIZE_INJ_GLOBAL_PARAMS_   0x04
// raw size (padding not included) of a tag type
// value (raw size) = _GLOB_TAG_TYPE_RAW_SIZE_INJ_GLOBAL_PARAMS_
#define _GLOB_TAG_TYPE_RAW_SIZE_INJ_GLOBAL_PARAMS_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _GLOB_TAG_TYPE_ALIGNMENT_INJ_GLOBAL_PARAMS_
#define _GLOB_TAG_TYPE_ALIGNMENT_INJ_GLOBAL_PARAMS_ 0x00
// Global tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _GLOB_MEMBER_TYPE_INJ_GLOBAL_PARAMS_active_bank_chans_ T_union
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = SPRAM + [variable SPRAM offset] + _GLOB_MEMBER_BYTEOFFSET_INJ_GLOBAL_PARAMS_active_bank_chans_
#define _GLOB_MEMBER_BYTEOFFSET_INJ_GLOBAL_PARAMS_active_bank_chans_ 0x00
#define _GLOB_MEMBER_TYPE_UNION_INJ_GLOBAL_PARAMS_active_bank_chans_ INJ_32_BIT
// defines for type union INJ_32_BIT
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _GLOB_TAG_TYPE_SIZE_INJ_32_BIT_
#define _GLOB_TAG_TYPE_SIZE_INJ_32_BIT_          0x04
// raw size (padding not included) of a tag type
// value (raw size) = _GLOB_TAG_TYPE_RAW_SIZE_INJ_32_BIT_
#define _GLOB_TAG_TYPE_RAW_SIZE_INJ_32_BIT_      0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _GLOB_TAG_TYPE_ALIGNMENT_INJ_32_BIT_
#define _GLOB_TAG_TYPE_ALIGNMENT_INJ_32_BIT_     0x00
// Global tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _GLOB_MEMBER_TYPE_INJ_32_BIT_parts_      T_struct
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = SPRAM + [variable SPRAM offset] + _GLOB_MEMBER_BYTEOFFSET_INJ_32_BIT_parts_
#define _GLOB_MEMBER_BYTEOFFSET_INJ_32_BIT_parts_ 0x00
#define _GLOB_MEMBER_TYPE_STRUCT_INJ_32_BIT_parts_ AW_ANONYMOUS_STRUCT_0
#define _GLOB_MEMBER_TYPE_INJ_32_BIT_all_        T_uint32
#define _GLOB_MEMBER_BYTEOFFSET_INJ_32_BIT_all_  0x00

// Global Struct/Union Variable address
// address = SPRAM + _GLOB_VAR_STRUCT_inj_global_
#define _GLOB_VAR_STRUCT_inj_global_             0x10
#define _GLOB_VAR_TYPE_STRUCT_inj_global_        INJ_GLOBAL_PARAMS

// Global Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _GLOB_VAR_TYPE_eng_pos_state_            T_uint8
#define _GLOB_VAR_TYPE_eng_cycle_tcr2_ticks_     T_uint24
#define _GLOB_VAR_TYPE_eng_cycle_tcr2_start_     T_uint24
#define _GLOB_VAR_TYPE_eng_trr_norm_             T_uint24
#define _GLOB_VAR_TYPE_tooth_period_             T_uint24
#define _GLOB_VAR_TYPE_inj_global_               T_struct
#define _GLOB_VAR_TYPE__Global_error_data_       T_sint32

// Global Variable/Data Size (not including scratchpad)
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_
#define _GLOBAL_VAR_SIZE_                        0x18

// Global Scratchpad Base Address in bytes
// address (start) = SPRAM + _GLOBAL_SCRATCHPAD_BASE_ADDR_
#define _GLOBAL_SCRATCHPAD_BASE_ADDR_            0x18

// Global Scratchpad Data Size in bytes
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_ + _GLOBAL_SCRATCHPAD_SIZE_
#define _GLOBAL_SCRATCHPAD_SIZE_                 0x00

// Total Global Data Size (starts at address 0, includes any global scratchpad allocation)
// address (end) = SPRAM + _GLOBAL_DATA_SIZE_
#define _GLOBAL_DATA_SIZE_                       0x18

// User Engine Variable/Data Size (not including scratchpad)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_
#define _ENGINE_VAR_SIZE_                        0x00

// Engine Scratchpad Data Size in bytes
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_ + _ENGINE_SCRATCHPAD_SIZE_
#define _ENGINE_SCRATCHPAD_SIZE_                 0x00

// Total Engine Data Size (starts at engine address 0, includes any engine scratchpad allocation)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_DATA_SIZE_
#define _ENGINE_DATA_SIZE_                       0x00

// Amount of DATA RAM (in bytes) required for the stack
// (ideally, programs require none)
// #define CHANNEL_FRAME_START (((_GLOBAL_DATA_SIZE_ + _STACK_SIZE_) + 7) & ~7)
#define _STACK_SIZE_                             0x00

// Default channel frame base address definitions
// One for the single eTPU case, one for the dual eTPU case
#define _CHANNEL_FRAME_1ETPU_BASE_ADDR  0x18
#define _CHANNEL_FRAME_2ETPU_BASE_ADDR  0x18

#if 0
// This section gives an example of how stack bases should
// be initialized for each new channel frame (replace FUNC1, etc.
// with actual function names) in a simulator script file.  Host
// code should use the same mechanism.  The conditional initialization
// is done because a channel frame will not have a stack base allocated
// if it is not needed.
#ifdef _CPBA24_FUNC1___STACKBASE_
write_chan_data24(FUNC1_CHAN1, _CPBA24_FUNC1___STACKBASE_, _ETPU_A_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC1___STACKBASE_
#ifdef _CPBA24_FUNC2___STACKBASE_
write_chan_data24(FUNC2_CHAN1, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN2, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN3, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN4, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC2___STACKBASE_
// continue on through all channels for both eTPUs...
#endif // 0

//============================================================================
//==========     TG

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_TG_;
#define _FUNCTION_NUM_TG_                        0x07

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_TG_;
#define _ENTRY_TABLE_TYPE_TG_                    0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_TG_;
#define _ENTRY_TABLE_PIN_DIR_TG_                 0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_TG_teeth_till_gap_
#define _CPBA8_TG_teeth_till_gap_                0x00
#define _CPBA8_TG_teeth_in_gap_                  0x04
#define _CPBA8_TG_teeth_per_cycle_               0x08
#define _CPBA8_TG_tooth_counter_gap_             0x0C
#define _CPBA8_TG_tooth_counter_cycle_           0x10
#define _CPBA8_TG_cam_chan_                      0x14
#define _CPBA8_TG_generation_disable_            0x18

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_TG_tooth_tcr1_time_
#define _CPBA24_TG_tooth_tcr1_time_              0x01
#define _CPBA24_TG_tooth_period_actual_          0x05
#define _CPBA24_TG_tooth_period_target_          0x09
#define _CPBA24_TG_accel_ratio_                  0x0D
#define _CPBA24_TG_p_cam_tooth_first_            0x11
#define _CPBA24_TG_p_cam_tooth_                  0x15

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_TG_tooth_tcr1_time_           T_uint24
#define _CPBA_TYPE_TG_tooth_period_actual_       T_sint24
#define _CPBA_TYPE_TG_tooth_period_target_       T_sint24
#define _CPBA_TYPE_TG_accel_ratio_               T_ufract24
#define _CPBA_TYPE_TG_p_cam_tooth_first_         T_ptr
#define _CPBA_TYPE_PTR_TG_p_cam_tooth_first_     T_uint8
#define _CPBA_TYPE_TG_p_cam_tooth_               T_ptr
#define _CPBA_TYPE_PTR_TG_p_cam_tooth_           T_uint8
#define _CPBA_TYPE_TG_teeth_till_gap_            T_uint8
#define _CPBA_TYPE_TG_teeth_in_gap_              T_sint8
#define _CPBA_TYPE_TG_teeth_per_cycle_           T_uint8
#define _CPBA_TYPE_TG_tooth_counter_gap_         T_uint8
#define _CPBA_TYPE_TG_tooth_counter_cycle_       T_uint8
#define _CPBA_TYPE_TG_cam_chan_                  T_uint8
#define _CPBA_TYPE_TG_generation_disable_        T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_TG_;
#define _FRAME_SIZE_TG_                          0x20

//============================================================================
//==========     SPARK

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_SPARK_;
#define _FUNCTION_NUM_SPARK_                     0x06

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_SPARK_;
#define _ENTRY_TABLE_TYPE_SPARK_                 0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_SPARK_;
#define _ENTRY_TABLE_PIN_DIR_SPARK_              0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_SPARK_spark_count_
#define _CPBA8_SPARK_spark_count_                0x00
#define _CPBA8_SPARK_spark_counter_              0x04
#define _CPBA8_SPARK_multi_pulse_count_          0x08
#define _CPBA8_SPARK_multi_pulse_counter_        0x0C
#define _CPBA8_SPARK_state_                      0x10
#define _CPBA8_SPARK_error_                      0x14
#define _CPBA8_SPARK_generation_disable_         0x18
#define _CPBA8_SPARK_is_first_recalc_            0x1C
#define _CPBA8_BOOLBITOFFSET_SPARK_is_first_recalc_ 0x07

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_SPARK_tdc_angle_
#define _CPBA24_SPARK_tdc_angle_                 0x01
#define _CPBA24_SPARK_tdc_angle_actual_          0x05
#define _CPBA24_SPARK_angle_offset_recalc_       0x09
#define _CPBA24_SPARK_dwell_time_min_            0x0D
#define _CPBA24_SPARK_dwell_time_max_            0x11
#define _CPBA24_SPARK_multi_on_time_             0x15
#define _CPBA24_SPARK_multi_off_time_            0x19
#define _CPBA24_SPARK_p_single_spark_first_      0x1D
#define _CPBA24_SPARK_p_single_spark_            0x21
#define _CPBA24_SPARK_pulse_start_time_          0x25
#define _CPBA24_SPARK_dwell_time_applied_        0x29
#define _CPBA24_SPARK_dwell_time_                0x2D
#define _CPBA24_SPARK_end_angle_                 0x31
#define _CPBA24_SPARK_angle_offset_recalc_working_ 0x35

// tag type info used by channel frame variables

// defines for type struct SINGLE_SPARK
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_SINGLE_SPARK_
#define _CHAN_TAG_TYPE_SIZE_SINGLE_SPARK_        0x08
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_SINGLE_SPARK_
#define _CHAN_TAG_TYPE_RAW_SIZE_SINGLE_SPARK_    0x08
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_SINGLE_SPARK_
#define _CHAN_TAG_TYPE_ALIGNMENT_SINGLE_SPARK_   0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_SPARK_SINGLE_SPARK_multi_pulse_count_ T_uint8
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_SPARK_SINGLE_SPARK_multi_pulse_count_
#define _CHAN_MEMBER_BYTEOFFSET_SPARK_SINGLE_SPARK_multi_pulse_count_ 0x00
#define _CHAN_MEMBER_TYPE_SPARK_SINGLE_SPARK_end_angle_ T_sint24
#define _CHAN_MEMBER_BYTEOFFSET_SPARK_SINGLE_SPARK_end_angle_ 0x01
#define _CHAN_MEMBER_TYPE_SPARK_SINGLE_SPARK_dwell_time_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_SPARK_SINGLE_SPARK_dwell_time_ 0x05

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_SPARK_tdc_angle_              T_sint24
#define _CPBA_TYPE_SPARK_tdc_angle_actual_       T_sint24
#define _CPBA_TYPE_SPARK_angle_offset_recalc_    T_sint24
#define _CPBA_TYPE_SPARK_dwell_time_min_         T_uint24
#define _CPBA_TYPE_SPARK_dwell_time_max_         T_uint24
#define _CPBA_TYPE_SPARK_multi_on_time_          T_uint24
#define _CPBA_TYPE_SPARK_multi_off_time_         T_uint24
#define _CPBA_TYPE_SPARK_p_single_spark_first_   T_ptr
#define _CPBA_TYPE_PTR_SPARK_p_single_spark_first_ T_struct
#define _CPBA_TYPE_SPARK_spark_count_            T_uint8
#define _CPBA_TYPE_SPARK_p_single_spark_         T_ptr
#define _CPBA_TYPE_PTR_SPARK_p_single_spark_     T_struct
#define _CPBA_TYPE_SPARK_spark_counter_          T_uint8
#define _CPBA_TYPE_SPARK_pulse_start_time_       T_uint24
#define _CPBA_TYPE_SPARK_dwell_time_applied_     T_uint24
#define _CPBA_TYPE_SPARK_dwell_time_             T_uint24
#define _CPBA_TYPE_SPARK_end_angle_              T_sint24
#define _CPBA_TYPE_SPARK_multi_pulse_count_      T_uint8
#define _CPBA_TYPE_SPARK_multi_pulse_counter_    T_uint8
#define _CPBA_TYPE_SPARK_state_                  T_uint8
#define _CPBA_TYPE_SPARK_error_                  T_uint8
#define _CPBA_TYPE_SPARK_generation_disable_     T_uint8
#define _CPBA_TYPE_SPARK_angle_offset_recalc_working_ T_sint24
#define _CPBA_TYPE_SPARK_is_first_recalc_        T_bool

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_SPARK_;
#define _FRAME_SIZE_SPARK_                       0x38

//============================================================================
//==========     CRANK

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_CRANK_;
#define _FUNCTION_NUM_CRANK_                     0x01
#define _FUNCTION_NUM_CRANK_CRANK_EMUL_          0x02

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_CRANK_;
#define _ENTRY_TABLE_TYPE_CRANK_                 0x01
#define _ENTRY_TABLE_TYPE_CRANK_CRANK_EMUL_      0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_CRANK_;
#define _ENTRY_TABLE_PIN_DIR_CRANK_              0x00
#define _ENTRY_TABLE_PIN_DIR_CRANK_CRANK_EMUL_   0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_CRANK_tcr1_clock_source_div1_
#define _CPBA8_CRANK_tcr1_clock_source_div1_     0x00
#define _CPBA8_CRANK_teeth_till_gap_             0x04
#define _CPBA8_CRANK_teeth_in_gap_               0x08
#define _CPBA8_CRANK_teeth_per_cycle_            0x0C
#define _CPBA8_CRANK_teeth_per_sync_             0x10
#define _CPBA8_CRANK_tooth_counter_gap_          0x14
#define _CPBA8_CRANK_tooth_counter_cycle_        0x18
#define _CPBA8_CRANK_blank_teeth_                0x1C
#define _CPBA8_CRANK_state_                      0x20
#define _CPBA8_CRANK_error_                      0x24

// 16-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA16_CRANK_misscnt_mask_
#define _CPBA16_CRANK_misscnt_mask_              0x54

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_CRANK_blank_time_
#define _CPBA24_CRANK_blank_time_                0x01
#define _CPBA24_CRANK_tcr2_ticks_per_tooth_      0x05
#define _CPBA24_CRANK_tcr2_ticks_per_add_tooth_  0x09
#define _CPBA24_CRANK_last_tooth_tcr1_time_      0x0D
#define _CPBA24_CRANK_last_tooth_period_         0x11
#define _CPBA24_CRANK_last_tooth_period_norm_    0x15
#define _CPBA24_CRANK_last_last_tooth_period_norm_ 0x19
#define _CPBA24_CRANK_additional_tooth_period_   0x1D
#define _CPBA24_CRANK_tcr2_adjustment_           0x21
#define _CPBA24_CRANK_gap_ratio_                 0x25
#define _CPBA24_CRANK_win_ratio_normal_          0x29
#define _CPBA24_CRANK_win_ratio_across_gap_      0x2D
#define _CPBA24_CRANK_win_ratio_after_gap_       0x31
#define _CPBA24_CRANK_win_ratio_after_timeout_   0x35
#define _CPBA24_CRANK_first_tooth_timeout_       0x39
#define _CPBA24_CRANK_tooth_period_log_          0x51

// 32-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA32_CRANK_link_cam_
#define _CPBA32_CRANK_link_cam_                  0x3C
#define _CPBA32_CRANK_link_1_                    0x40
#define _CPBA32_CRANK_link_2_                    0x44
#define _CPBA32_CRANK_link_3_                    0x48
#define _CPBA32_CRANK_link_4_                    0x4C

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_CRANK_blank_time_             T_uint24
#define _CPBA_TYPE_CRANK_tcr1_clock_source_div1_ T_uint8
#define _CPBA_TYPE_CRANK_tcr2_ticks_per_tooth_   T_uint24
#define _CPBA_TYPE_CRANK_tcr2_ticks_per_add_tooth_ T_uint24
#define _CPBA_TYPE_CRANK_last_tooth_tcr1_time_   T_uint24
#define _CPBA_TYPE_CRANK_last_tooth_period_      T_uint24
#define _CPBA_TYPE_CRANK_last_tooth_period_norm_ T_uint24
#define _CPBA_TYPE_CRANK_last_last_tooth_period_norm_ T_uint24
#define _CPBA_TYPE_CRANK_additional_tooth_period_ T_uint24
#define _CPBA_TYPE_CRANK_tcr2_adjustment_        T_sint24
#define _CPBA_TYPE_CRANK_gap_ratio_              T_ufract24
#define _CPBA_TYPE_CRANK_win_ratio_normal_       T_ufract24
#define _CPBA_TYPE_CRANK_win_ratio_across_gap_   T_ufract24
#define _CPBA_TYPE_CRANK_win_ratio_after_gap_    T_ufract24
#define _CPBA_TYPE_CRANK_win_ratio_after_timeout_ T_ufract24
#define _CPBA_TYPE_CRANK_first_tooth_timeout_    T_uint24
#define _CPBA_TYPE_CRANK_link_cam_               T_uint32
#define _CPBA_TYPE_CRANK_link_1_                 T_uint32
#define _CPBA_TYPE_CRANK_link_2_                 T_uint32
#define _CPBA_TYPE_CRANK_link_3_                 T_uint32
#define _CPBA_TYPE_CRANK_link_4_                 T_uint32
#define _CPBA_TYPE_CRANK_teeth_till_gap_         T_uint8
#define _CPBA_TYPE_CRANK_teeth_in_gap_           T_sint8
#define _CPBA_TYPE_CRANK_misscnt_mask_           T_uint16
#define _CPBA_TYPE_CRANK_teeth_per_cycle_        T_uint8
#define _CPBA_TYPE_CRANK_teeth_per_sync_         T_uint8
#define _CPBA_TYPE_CRANK_tooth_counter_gap_      T_uint8
#define _CPBA_TYPE_CRANK_tooth_counter_cycle_    T_uint8
#define _CPBA_TYPE_CRANK_blank_teeth_            T_uint8
#define _CPBA_TYPE_CRANK_state_                  T_uint8
#define _CPBA_TYPE_CRANK_error_                  T_uint8
#define _CPBA_TYPE_CRANK_tooth_period_log_       T_ptr
#define _CPBA_TYPE_PTR_CRANK_tooth_period_log_   T_uint24

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_CRANK_;
#define _FRAME_SIZE_CRANK_                       0x58

//============================================================================
//==========     KNOCK

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_KNOCK_;
#define _FUNCTION_NUM_KNOCK_                     0x05

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_KNOCK_;
#define _ENTRY_TABLE_TYPE_KNOCK_                 0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_KNOCK_;
#define _ENTRY_TABLE_PIN_DIR_KNOCK_              0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_KNOCK_window_count_
#define _CPBA8_KNOCK_window_count_               0x00
#define _CPBA8_KNOCK_window_counter_             0x04
#define _CPBA8_KNOCK_irq_dma_options_            0x08

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_KNOCK_p_window_first_
#define _CPBA24_KNOCK_p_window_first_            0x01
#define _CPBA24_KNOCK_p_window_                  0x05
#define _CPBA24_KNOCK_tdc_angle_                 0x09
#define _CPBA24_KNOCK_tdc_angle_actual_          0x0D
#define _CPBA24_KNOCK_tcr2_window_start_         0x11
#define _CPBA24_KNOCK_tcr2_window_end_           0x15
#define _CPBA24_KNOCK_trigger_period_            0x19

// tag type info used by channel frame variables

// defines for type struct KNOCK_WINDOW
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_KNOCK_WINDOW_
#define _CHAN_TAG_TYPE_SIZE_KNOCK_WINDOW_        0x08
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_KNOCK_WINDOW_
#define _CHAN_TAG_TYPE_RAW_SIZE_KNOCK_WINDOW_    0x07
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_KNOCK_WINDOW_
#define _CHAN_TAG_TYPE_ALIGNMENT_KNOCK_WINDOW_   0x01
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_KNOCK_KNOCK_WINDOW_start_ T_sint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_KNOCK_KNOCK_WINDOW_start_
#define _CHAN_MEMBER_BYTEOFFSET_KNOCK_KNOCK_WINDOW_start_ 0x00
#define _CHAN_MEMBER_TYPE_KNOCK_KNOCK_WINDOW_width_ T_sint24
#define _CHAN_MEMBER_BYTEOFFSET_KNOCK_KNOCK_WINDOW_width_ 0x04

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_KNOCK_window_count_           T_uint8
#define _CPBA_TYPE_KNOCK_p_window_first_         T_ptr
#define _CPBA_TYPE_PTR_KNOCK_p_window_first_     T_struct
#define _CPBA_TYPE_KNOCK_window_counter_         T_uint8
#define _CPBA_TYPE_KNOCK_p_window_               T_ptr
#define _CPBA_TYPE_PTR_KNOCK_p_window_           T_struct
#define _CPBA_TYPE_KNOCK_tdc_angle_              T_sint24
#define _CPBA_TYPE_KNOCK_tdc_angle_actual_       T_sint24
#define _CPBA_TYPE_KNOCK_tcr2_window_start_      T_sint24
#define _CPBA_TYPE_KNOCK_tcr2_window_end_        T_sint24
#define _CPBA_TYPE_KNOCK_trigger_period_         T_uint24
#define _CPBA_TYPE_KNOCK_irq_dma_options_        T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_KNOCK_;
#define _FRAME_SIZE_KNOCK_                       0x20

//============================================================================
//==========     INJ

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_INJ_;
#define _FUNCTION_NUM_INJ_                       0x04

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_INJ_;
#define _ENTRY_TABLE_TYPE_INJ_                   0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_INJ_;
#define _ENTRY_TABLE_PIN_DIR_INJ_                0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_INJ_injection_count_
#define _CPBA8_INJ_injection_count_              0x00
#define _CPBA8_INJ_injection_counter_            0x04
#define _CPBA8_INJ_phase_counter_                0x08
#define _CPBA8_INJ_bank_chan_count_              0x0C
#define _CPBA8_INJ_error_                        0x14
#define _CPBA8_INJ_inactive_polarities_          0x18

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_INJ_p_injection_first_
#define _CPBA24_INJ_p_injection_first_           0x01
#define _CPBA24_INJ_p_injection_                 0x05
#define _CPBA24_INJ_p_phase_                     0x09
#define _CPBA24_INJ_bank_chans_                  0x0D
#define _CPBA24_INJ_angle_irq_                   0x15
#define _CPBA24_INJ_angle_stop_                  0x19
#define _CPBA24_INJ_tdc_angle_                   0x1D
#define _CPBA24_INJ_tdc_angle_actual_            0x21

// tag type info used by channel frame variables

// defines for type struct INJ_INJECTION
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_INJ_INJECTION_
#define _CHAN_TAG_TYPE_SIZE_INJ_INJECTION_       0x08
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_INJ_INJECTION_
#define _CHAN_TAG_TYPE_RAW_SIZE_INJ_INJECTION_   0x08
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_INJ_INJECTION_
#define _CHAN_TAG_TYPE_ALIGNMENT_INJ_INJECTION_  0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_INJ_INJ_INJECTION_phase_count_ T_uint8
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_INJECTION_phase_count_
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_INJECTION_phase_count_ 0x00
#define _CHAN_MEMBER_TYPE_INJ_INJ_INJECTION_p_phase_first_ T_ptr
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_INJECTION_p_phase_first_ 0x01
#define _CHAN_MEMBER_TYPE_INJ_INJ_INJECTION_angle_start_ T_sint24
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_INJECTION_angle_start_ 0x05
// defines for type struct INJ_PHASE
#define _CHAN_TAG_TYPE_SIZE_INJ_PHASE_           0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_INJ_PHASE_       0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_INJ_PHASE_      0x00
#define _CHAN_MEMBER_TYPE_INJ_INJ_PHASE_dmas_outputs_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_PHASE_dmas_outputs_ 0x00
#define _CHAN_MEMBER_TYPE_INJ_INJ_PHASE_duration_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_PHASE_duration_ 0x01
// defines for type struct AW_ANONYMOUS_STRUCT_0
#define _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_0_ 0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_0_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_0_ 0x00
#define _CHAN_MEMBER_TYPE_INJ_AW_ANONYMOUS_STRUCT_0_bits31_24_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_INJ_AW_ANONYMOUS_STRUCT_0_bits31_24_ 0x00
#define _CHAN_MEMBER_TYPE_INJ_AW_ANONYMOUS_STRUCT_0_bits23_0_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_INJ_AW_ANONYMOUS_STRUCT_0_bits23_0_ 0x01
// defines for type union INJ_32_BIT
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_INJ_32_BIT_
#define _CHAN_TAG_TYPE_SIZE_INJ_32_BIT_          0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_INJ_32_BIT_
#define _CHAN_TAG_TYPE_RAW_SIZE_INJ_32_BIT_      0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_INJ_32_BIT_
#define _CHAN_TAG_TYPE_ALIGNMENT_INJ_32_BIT_     0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_INJ_INJ_32_BIT_parts_  T_struct
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_32_BIT_parts_
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_32_BIT_parts_ 0x00
#define _CHAN_MEMBER_TYPE_STRUCT_INJ_INJ_32_BIT_parts_ AW_ANONYMOUS_STRUCT_0
#define _CHAN_MEMBER_TYPE_INJ_INJ_32_BIT_all_    T_uint32
#define _CHAN_MEMBER_BYTEOFFSET_INJ_INJ_32_BIT_all_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_INJ_bank_chans_mask_
#define _CPBA_UNION_INJ_bank_chans_mask_         0x10
#define _CPBA_TYPE_UNION_INJ_bank_chans_mask_    INJ_32_BIT

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_INJ_injection_count_          T_uint8
#define _CPBA_TYPE_INJ_p_injection_first_        T_ptr
#define _CPBA_TYPE_PTR_INJ_p_injection_first_    T_struct
#define _CPBA_TYPE_INJ_injection_counter_        T_uint8
#define _CPBA_TYPE_INJ_p_injection_              T_ptr
#define _CPBA_TYPE_PTR_INJ_p_injection_          T_struct
#define _CPBA_TYPE_INJ_phase_counter_            T_uint8
#define _CPBA_TYPE_INJ_p_phase_                  T_ptr
#define _CPBA_TYPE_PTR_INJ_p_phase_              T_struct
#define _CPBA_TYPE_INJ_bank_chan_count_          T_uint8
#define _CPBA_TYPE_INJ_bank_chans_               T_uint24
#define _CPBA_TYPE_INJ_bank_chans_mask_          T_union
#define _CPBA_TYPE_INJ_error_                    T_uint8
#define _CPBA_TYPE_INJ_angle_irq_                T_sint24
#define _CPBA_TYPE_INJ_inactive_polarities_      T_uint8
#define _CPBA_TYPE_INJ_angle_stop_               T_sint24
#define _CPBA_TYPE_INJ_tdc_angle_                T_sint24
#define _CPBA_TYPE_INJ_tdc_angle_actual_         T_sint24

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_INJ_;
#define _FRAME_SIZE_INJ_                         0x28

//============================================================================
//==========     FUEL

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_FUEL_;
#define _FUNCTION_NUM_FUEL_                      0x03

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_FUEL_;
#define _ENTRY_TABLE_TYPE_FUEL_                  0x01

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_FUEL_;
#define _ENTRY_TABLE_PIN_DIR_FUEL_               0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_FUEL_generation_disable_
#define _CPBA8_FUEL_generation_disable_          0x00
#define _CPBA8_FUEL_error_                       0x04
#define _CPBA8_FUEL_is_await_recalc_             0x08
#define _CPBA8_BOOLBITOFFSET_FUEL_is_await_recalc_ 0x07
#define _CPBA8_FUEL_is_first_recalc_             0x08
#define _CPBA8_BOOLBITOFFSET_FUEL_is_first_recalc_ 0x06

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_FUEL_tdc_angle_
#define _CPBA24_FUEL_tdc_angle_                  0x01
#define _CPBA24_FUEL_tdc_angle_actual_           0x05
#define _CPBA24_FUEL_angle_normal_end_           0x09
#define _CPBA24_FUEL_angle_stop_                 0x0D
#define _CPBA24_FUEL_angle_offset_recalc_        0x11
#define _CPBA24_FUEL_injection_time_             0x15
#define _CPBA24_FUEL_compensation_time_          0x19
#define _CPBA24_FUEL_injection_time_minimum_     0x1D
#define _CPBA24_FUEL_off_time_minimum_           0x21
#define _CPBA24_FUEL_injection_time_applied_     0x25
#define _CPBA24_FUEL_injection_time_applied_cpu_ 0x29
#define _CPBA24_FUEL_injection_start_angle_      0x2D
#define _CPBA24_FUEL_injection_start_angle_cpu_  0x31
#define _CPBA24_FUEL_pulse_start_time_           0x35
#define _CPBA24_FUEL_pulse_end_time_             0x39
#define _CPBA24_FUEL_angle_stop_actual_last_     0x3D
#define _CPBA24_FUEL_angle_offset_recalc_working_ 0x41

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_FUEL_tdc_angle_               T_sint24
#define _CPBA_TYPE_FUEL_tdc_angle_actual_        T_sint24
#define _CPBA_TYPE_FUEL_angle_normal_end_        T_sint24
#define _CPBA_TYPE_FUEL_angle_stop_              T_sint24
#define _CPBA_TYPE_FUEL_angle_offset_recalc_     T_sint24
#define _CPBA_TYPE_FUEL_injection_time_          T_sint24
#define _CPBA_TYPE_FUEL_compensation_time_       T_sint24
#define _CPBA_TYPE_FUEL_injection_time_minimum_  T_sint24
#define _CPBA_TYPE_FUEL_off_time_minimum_        T_sint24
#define _CPBA_TYPE_FUEL_injection_time_applied_  T_sint24
#define _CPBA_TYPE_FUEL_injection_time_applied_cpu_ T_sint24
#define _CPBA_TYPE_FUEL_injection_start_angle_   T_sint24
#define _CPBA_TYPE_FUEL_injection_start_angle_cpu_ T_sint24
#define _CPBA_TYPE_FUEL_pulse_start_time_        T_sint24
#define _CPBA_TYPE_FUEL_pulse_end_time_          T_sint24
#define _CPBA_TYPE_FUEL_generation_disable_      T_uint8
#define _CPBA_TYPE_FUEL_error_                   T_uint8
#define _CPBA_TYPE_FUEL_angle_stop_actual_last_  T_sint24
#define _CPBA_TYPE_FUEL_angle_offset_recalc_working_ T_sint24
#define _CPBA_TYPE_FUEL_is_await_recalc_         T_bool
#define _CPBA_TYPE_FUEL_is_first_recalc_         T_bool

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_FUEL_;
#define _FRAME_SIZE_FUEL_                        0x48

//============================================================================
//==========     CAM

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_CAM_;
#define _FUNCTION_NUM_CAM_                       0x00

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_CAM_;
#define _ENTRY_TABLE_TYPE_CAM_                   0x00

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_CAM_;
#define _ENTRY_TABLE_PIN_DIR_CAM_                0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_CAM_error_
#define _CPBA8_CAM_error_                        0x00

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_CAM_log_size_
#define _CPBA24_CAM_log_size_                    0x01
#define _CPBA24_CAM_log_idx_                     0x05
#define _CPBA24_CAM_log_count_                   0x09
#define _CPBA24_CAM_log_                         0x0D

// tag type info used by channel frame variables

// defines for type struct CAM_LOG
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_CAM_LOG_
#define _CHAN_TAG_TYPE_SIZE_CAM_LOG_             0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_CAM_LOG_
#define _CHAN_TAG_TYPE_RAW_SIZE_CAM_LOG_         0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_CAM_LOG_
#define _CHAN_TAG_TYPE_ALIGNMENT_CAM_LOG_        0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_CAM_CAM_LOG_trans_     T_sint8
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_CAM_CAM_LOG_trans_
#define _CHAN_MEMBER_BYTEOFFSET_CAM_CAM_LOG_trans_ 0x00
#define _CHAN_MEMBER_TYPE_CAM_CAM_LOG_angle_     T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_CAM_CAM_LOG_angle_ 0x01

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_CAM_log_size_                 T_uint24
#define _CPBA_TYPE_CAM_log_idx_                  T_uint24
#define _CPBA_TYPE_CAM_log_count_                T_uint24
#define _CPBA_TYPE_CAM_error_                    T_uint8
#define _CPBA_TYPE_CAM_log_                      T_ptr
#define _CPBA_TYPE_PTR_CAM_log_                  T_struct

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_CAM_;
#define _FRAME_SIZE_CAM_                         0x10

#endif // __etpu_set_defines_H
